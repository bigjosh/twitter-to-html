<!DOCTYPE html>
<!-- This page is (c) 2025 josh levine [josh.com]. For more info, check out josh.com/2025/01/19/a-utility-to-create-a-static-html-website-from-your-twitter-posts/ -->
<html>
<head>
  <meta charset="UTF-8" />
  <title>Twitter Export to Static HTML</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem auto;
      max-width: 640px;
      text-align: center;
    }
    .container {
      border: 1px solid #ccc;
      padding: 1rem;
      background: #f9f9f9;
      border-radius: 8px;
    }
    h1 {
      margin-bottom: 1rem;
    }
    #file-input {
      margin-bottom: 1rem;
    }

    .progress-area {
      margin: 1rem 0;
      border-radius: 4px;
      border: 1px solid #ccc;
      overflow: hidden;
    }
    .progress-header {
      background: #1DA1F2;  /* Twitter's signature blue color */
      color: white;
      padding: 0.5rem 1rem;
      margin: 0;
      font-size: 1rem;
      font-weight: bold;
    }
    .progress-content {
      padding: 1rem;
      background: #f9f9f9;
    }
    .progress-area.error {
      border-color: #ef9a9a;
    }
    .progress-area.error .progress-header {
      background: #c62828;
    }
    .progress-area.error .progress-content {
      background: #ffebee;
      color: #c62828;
    }
    code {
      white-space: nowrap;
      background-color: #e3f2fd;  /* Light blue background */
      color: #1565c0;            /* Dark blue text */
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Consolas', monospace;
    }
    .instructions {
      margin: 1rem 0;
      padding: 0 2rem;
    }
    .instructions ol {
      margin: 0;
      padding-left: 2rem;

    }
    .instructions li {
      margin-bottom: 1rem;
      text-align: left;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Twitter Export to Static HTML</h1>
    <p>Read the full article about this tool on <a href="https://wp.josh.com/2025/01/19/a-utility-to-create-a-static-html-website-from-your-twitter-posts/">josh.com</a></p>
    <div class="instructions">
      <ol>
        <li>Click the "Choose Files" button below</li>
        <li>Select the <code>tweets.js</code> and optionally <code>note-tweet.js</code> files from your twitter export. You can select multipule files by holding the control or command key while clicking.</li>
        <li>Wait until the status window says the process is complete</li>
        <li>Click the "Save tweets.html" button to save the newly generated HTML file</li>
      </ol>
    </div>
    <p></p>
    <input type="file" id="file-input" accept=".js" multiple />
    <div id="progress-area" class="progress-area">
      <h3 class="progress-header">Status</h3>
      <div class="progress-content">
        <p id="progress-message"></p>
        <p id="warning-message" style="display: none;"></p>
      </div>
    </div>  

    <!-- Hidden Static link that will be updated dynamically after the HTML has been generated -->
    <p><a id="download-link" href="#" download="tweets.html" style="display: none;">Save your new tweets.html file</a></p>

    <!--- <p><a id="open-link" href="#" target="_blank" style="display: none;">Open in New Tab (note that media will probably not be in the right directory)</a></p> -->

  </div>

  <script>

    // This is the relative path to the media files. This is what it was in my export, but you may need to change it
    // if it is different in your export or you want a different structure on your web server
    // Should include the trailing slash if not empty
    const mediapath = "tweets_media/";

    // Defined in date2string below
    const dateFormat = "YYYY-MM-DD HH:mm:ss";

    // Remeber the progress element so we can update it faster
    const progressMessageText = document.getElementById("progress-message");

    function updateProgressMessage(message) {
      progressMessageText.textContent = message;
    }

    updateProgressMessage("Waiting for files to be selected and processed");


    // Remeber the progress element so we can update it faster
    const progressWarningText = document.getElementById("progress-warning");

    function updateProgressWarningMessage(message) {
      progressWarningText.textContent = message;
    }


    let tweetsContent = null;

    /**
     * Removes `window.YTD... = ` or similar prefix, if present, returning raw JSON text.
     */
    function removeJavaScriptPrefix(content) {
      // Common patterns to remove:
      // e.g. window.YTD.tweets.part0 = [...];
      // You can adapt the regex for other variations
      return content
        .replace(/^window\.YTD\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\s*=\s*/, "") // remove prefix
        .replace(/;\s*$/, ""); // remove trailing semicolon if any
    }


    document.getElementById("file-input").addEventListener("change", async function() {
      const files = Array.from(this.files);
      if (files.length === 0) return;

      try {
        // Find the tweets.js file (required)
        const tweetsFile = files.find(f => f.name.toLowerCase() === 'tweets.js');
        if (!tweetsFile) {
          throw new Error("Please select your tweets.js file");
        }

        // Load main tweets into tweetsArray
        tweetsContent = await tweetsFile.text();

        updateProgressMessage("Loading tweets.js file...");
        tweetsContentCleaned = removeJavaScriptPrefix(tweetsContent);
        tweetsContent = null;   // Free up memory
        let tweetsArray = JSON.parse(tweetsContentCleaned).map( o=> o.tweet );    // Every tweet is in an object called `tweet`, so flatten that out for simplicity
        tweetsContentCleaned = null;  // Free up memory


        // Look for note-tweets.js (optional)
        const noteTweetsFile = files.find(f => f.name.toLowerCase() === 'note-tweet.js');

        let notesArray = [];    // By default we use an empty array rather than undefined so we can operate on it without checking
        let noteCount = 0;

        // Load note tweets if available
        if (noteTweetsFile) {

          updateProgressMessage("Loading note-tweets.js file...");
          const noteContent = await noteTweetsFile.text();
          const noteCleanContent = removeJavaScriptPrefix(noteContent);   // Remove the varabile name at the top of the file so just pure JSON
          notesArray = JSON.parse( noteCleanContent).map( o=> o.noteTweet );    // Every noteTweet is in an object called `noteTweet`, so flatten that out for simplicity            

          // We don't bother sorting the notes since they will end up in a set anyway. This does mean we could scamble the order of notes
          // in the very edge case that two tweets in a tweet storm have the same short version but different long versions. :/
        }


        updateProgressMessage("Generating static HTML...");

        // Generate the static HTML
        const staticHTML = generateStaticHTML(tweetsArray,notesArray);

        updateProgressMessage("Creating download blob...");

        // Create a Blob with the data and generate a Blob URL
        const blob = new Blob([staticHTML], { type: 'text/html' });
        const url = URL.createObjectURL(blob);


        // Update the download link
        const downloadLink = document.getElementById("download-link");
        downloadLink.href = url;    // Set the href attribute of the link to the Blob URL
        downloadLink.style.display = 'inline-block'; // Show the link (was inisible until now)

        /*
        // Update the open link
        const openLink = document.getElementById("open-link");
        openLink.href = url;    // Set the href attribute of the link to the Blob URL
        openLink.style.display = 'inline-block'; // Show the link (was inisible until now)
        */

        updateProgressMessage("Finished. Click the link below to save the newly generated HTML file.");
     
      } catch (err) {
        alert("Error: " + err.message + "\n" + err.stack);
        console.error(err);
      }
    });


    /** Note that tweets and notes escape different chars so we have to handle them seporately. All these had to be found emperically so the list might be longer **/

    /**
     * Escapes HTML special characters in a string
     * The tweets.js already has some chars escaped like ampersand and gt and lt
     * but it does not escape carridge return or quotes.
     * TODO: Are there others?  
     */
    function escapeTweetSpecialCharsToHtml(str) {
      return str
        .replace(/\r?\n/g, '<br>')
        .replace(/"/g, '&quot;');
    }

    /**
     * Escapes HTML special characters in a string
     * The tweets.js already has some chars escaped like ampersand and gt and lt
     * but it does not escape carridge return or quotes.
     * TODO: Are there others?  
     */
     function escapeNoteSpecialCharsToHtml(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\r?\n/g, '<br>')
        .replace(/"/g, '&quot;');
    }


    // Expand the shortened URLs in a tweet into their full URLs. Takes the names of the properties becuase
    // tweets and note tweet use differen property names.
    // Assumes urls array exists, which it should in the twitter export, it is empty for tweets with no URLs
    // = expandUrls(escapedTweetText,t.urls,"url","display_url","expanded_url");

    function expandUrls(text,urls,shortUrlProperty,displayUrlProperty,expandedUrlProperty) {

      urls.forEach(url => {
        text = text.replace(url[shortUrlProperty],`<a href="${url[expandedUrlProperty]}" target="_blank">${url[displayUrlProperty]}</a>`); 
      });

      return text;  
    }

    // Helper function to render a single tweet
    // expansion from a short tweet to a long note happens here if there is a matching note
    // We need to provide the full list of tweet so we can localize internal links. 
    function renderTweet(tweetWorkingRecord, isThread , tweetsWorkingRecords) {

      const t = tweetWorkingRecord.tweet;      // The orginal tweet object

      // now create the html for the mentions section
      let mentionsHtml = '';
      if (tweetWorkingRecord.mentions.length > 0) {
        mentionsHtml += `<table>\r`;              
        tweetWorkingRecord.mentions.forEach(m => {
          mentionsHtml += ` <tr><td><a href="https://x.com/${m.screen_name}" target="_blank" rel="noopener noreferrer">@${m.screen_name}</a></td><td>${m.name}</td></tr>\r`;              
        });
        mentionsHtml += `</table>\r`;              
      }

      // text now has external embeded URLs expaned and media URLs removed and any trailing spaces removed.

      // Next we build the reply HTML
      const tweetId = t.id_str;
      const tweetUrl = `https://x.com/i/web/status/${tweetId}`;

      // Check if this is a reply tweet
      let replyHtml = '';

      // Suppress the reply to line if this is in a thread (so it is obviously a reply to the tweet above it)
      if (t.in_reply_to_status_id_str && !isThread) {  

        const replyToUrl = `https://x.com/${t.in_reply_to_screen_name}/status/${t.in_reply_to_status_id_str}`;

        // Lets check if this a reply to one of our own tweets that appears above

        let localMatch = tweetsWorkingRecords.find(r => r.tweet.id_str === t.in_reply_to_status_id_str);

        let localLinkHtml = '';

        if (localMatch) {
          const localReplyToUrl = `#${t.in_reply_to_status_id_str}`;   // Local link to the reply tweet. No need to open in new tab
          localLinkHtml = `&nbsp(<a href="${localReplyToUrl}">local copy</a>)`;
        }

        // Link back to the tweet on x.com and inlcude the local link if there is a match
        replyHtml = `In reply to <a href="${replyToUrl}" target="_blank" rel="noopener noreferrer">@${t.in_reply_to_screen_name}/${t.in_reply_to_status_id_str}</a>`+localLinkHtml;
        
      }

      // The meat of the tweet
      let textHTML = '';

      if (tweetWorkingRecord.hasOwnProperty('normalizedNoteText') ) {   // We added `normalizedNoteText` property above in cases where we found a matching note (long form of a tweet )
        textHTML = tweetWorkingRecord.normalizedNoteText;  // Long tweet
      } else {
        textHTML = tweetWorkingRecord.normalizedText;       // Short tweet
      }

      // Next build the media HTML, if any

      const mediaFilenames = getMediaFilenames(tweetWorkingRecord.media);

      let mediaHtml = "";

      // Only bother to include the mdia div is there is any media. 
      if (mediaFilenames.length > 0) {
        
        mediaHtml +=  getMediaHtml(t,mediapath,mediaFilenames);
      }


      let headerHtml = "";

      headerHtml += `<div class="header">\r`;
      headerHtml += ` <span class="date">${date2string(tweetWorkingRecord.timestamp,dateFormat)}</span>\r`;
      headerHtml += ` <span class="id"><a href="${tweetUrl}" target="_blank" rel="noopener noreferrer">ID=${tweetId}</a></span>\r`;
      headerHtml += `</div>\r`;


      // ===== Finally we will build up the final html for the tweet so we can return it. 

      const threadClass = isThread ? ' thread-tweet' : '';

      let tweetHTML = "";

      tweetHTML += `<div class="container${threadClass}" id="${tweetId}">\r`;

      tweetHTML += ` ` +headerHtml;

      if (replyHtml) {
        tweetHTML += `<div class="reply-info">${replyHtml}</div>\r`;  
      }

      if (mentionsHtml) {  
        tweetHTML += `<div class="mentions">${mentionsHtml}</div>\r`;  
      }

  
      tweetHTML += `<div class="text">${textHTML}</div>\r`;

      if (mediaHtml) {
        tweetHTML += `<div class="media">${mediaHtml}</div>\r`;
      }

      tweetHTML += `</div>\r`;    // Close container

      return tweetHTML;

    }

    // Tries to find a matching note tweet. Assumes that the normalizedShortTweetText does not have trailing elipses.
    // If a match is found, then it is removed from the notesWorkingRecordsSet and we return the matching note record.
    // If no match is found, then returns null

    function findAndRemoveMatchingNote(timestamp, normalizedShortTweetText, notesWorkingRecordsSet) {
      // We can not use a find on the set because we have to do a partial match on the text
      for (let noteRecord of notesWorkingRecordsSet) {
        if (noteRecord.timestamp.getTime() === timestamp.getTime() && noteRecord.normalizedText.startsWith(normalizedShortTweetText)) {
          notesWorkingRecordsSet.delete(noteRecord);   // Remove the note from the set so we can only use it once
          return noteRecord;
        }
      }
      return null;  // If no match found, return null
    }


    function removeTrailingChar(str, charToRemove) {
      if (str.endsWith(charToRemove)) {
          return str.slice(0, -1);
      }
      return str;
    }


    function date2string(date, format) {
      const pad = n => n.toString().padStart(2, '0');
      const h = date.getHours();
      const replacements = {
        'YYYY': date.getFullYear(),
        'MM': pad(date.getMonth() + 1),
        'DD': pad(date.getDate()),
        'HH': pad(h),
        'hh': pad(h % 12 || 12),
        'mm': pad(date.getMinutes()),
        'ss': pad(date.getSeconds()),
        'AP': h < 12 ? 'AM' : 'PM'
      };
        
      return format.replace(/YYYY|MM|DD|HH|hh|mm|ss|AP/g, match => replacements[match]);
    }    

    /**
     * Generates a complete static HTML document from an array of tweet objects.
     * This HTML contains no JavaScript and references images in the `tweets_media` folder.
     * If no notes, then pass an empty array.
     * Tweets will be exported in the order they are in the array. Notes should be sorted in same order so that they line up with tweets.
     * It is very hard to match tweets with notes, so it is still possible to get them out of order.
     */


    function generateStaticHTML(tweets,notes) {


      // It looks like embeded URLs are different between the two versions of the tweet, so we need to expand them before comparing them. Urgh. 
      // They also use different escapeing functions, so we will have to normalize the texts before we can try finding matches.
      // tweets: "full_text" : "Sadly it seams that https://t.co/QKpprngYYE leaked my email address (and probably yours) to spammers.\n#surprisingspam\n\nHow I know:\nhttps://t.co/6m5GQ8IPHS\n\n(Interestingly, GMAIL silently ghosted this spam.  It is good that they correctly classified it as spam, but it is scary… https://t.co/gQcv8kzM4D",
      // notes: "text"       : "Sadly it seams that https://t.co/XVzYx757Tu leaked my email address (and probably yours) to spammers.\n#surprisingspam\n\nHow I know:\nhttps://t.co/bzKbdOkkrX\n\n(Interestingly, GMAIL silently ghosted this spam.  It is good that they correctly classified it as spam, but it is scary that they think it is ok to accept an email and then completely erase any record that it ever existed. Beware.)",

      // Make a set of notes since we can only use each note once. This will also make it faster to look the notes up.
      let notesWorkingRecordsSet = new Set();

      // We pre-exapand all the URLs notes so we can search on them (the tiny URLs are different between the short tweet and the long note tweet)
      // We have to escape the special chars for HTML first before we can expand the URLs becuase they will have HTML in them. 
      // Note that there are no media URLs or replyto @users in notes
      // Text text is called `text` in notes and `full_text` in tweets

      updateProgressMessage("Expanding URLs in notes.");
      
      notes.forEach( note => {

        //console.log("Note time: " + new Date(note.createdAt));

        // We have to escape the special chars for HTML first before we can expand the URLs becuase they will have HTML in them.
        // but anoyingly tweets and notes have different special chars that are preexpanded so we have to handle them seporately
        let noteText = escapeNoteSpecialCharsToHtml(note.core.text);    
        
        // ANd now we can expand all the URLs. We have to do this becuase the tiny URLs are different between the short tweet and the long note tweet

        noteText = expandUrls(noteText, note.core.urls, "shortUrl", "displayUrl", "expandedUrl");

        //console.log("Note out : " + noteText); 
        
        notesWorkingRecordsSet.add({
          "normalizedText": noteText,
          "timestamp": new Date(note.createdAt)
        });
      });


      // Next for all tweets lets remove leading @mentions, media URLS, and escape special chars and then expand all the URLS 
      // Once this is done, then the text in the tweets and notes will at least be in the same format

      let tweetcount = 0;

      let tweetsWorkingRecords = [];      
      
      tweets.forEach( tweet => {  

        // Starting point is the full text of the tweet
        let text = tweet.full_text;

        // First we strip all of the media URLs from the short tweet since they do not appear in the long note tweet
        // We will add the media into the output HTML later. 

        let media = [];   // If there are no media in this tweet, we will get an emptry arroy to iterate through
                          // This will be saved in tweetWorkingRecords so we can add the media items back to the HTML later

        if (tweet.extended_entities && tweet.extended_entities.media) {  
          media = tweet.extended_entities.media;        
        
          const mediaUrls = new Set();

          // Make a set of all media URLs
          media.forEach(m => {
            text = text.replace(m.url, '');   // Remove media URLs from text
          });

          // Trim any extra whitespace that might be left after removing URLs
          text = text.trim();
        }

        // Text is now the short tweet with media URLs removed
        
        // Next remove any leading mentions. We will add them as a different element from the usermentions array in entities. 
        // Not only do they look ugly at the begining there, they will also break our ability to find this tweet in notetweets
        // No need to save them becuase they are redundantly also stored in entities.user_mentions

        while (text.startsWith('@')) {
          // Find the end of the username (space or end of string)
          let spaceIndex = text.indexOf(' ');
          if (spaceIndex === -1) {
              text = '';  // If no space found, the entire text is a mention
              break;
          } else {
            // Skip the mention and the following space
            text = text.slice(spaceIndex + 1);
          }
        }

        // But since we are going to expand the URLs, we will also need to escape out the HTML special chars before we can expand the URLs becuase they will have HTML in them. 

        let escapedTweetText = escapeTweetSpecialCharsToHtml(text);    
        
        // Now we can expand all the embeded URLs. We have to do this becuase the tiny URLs are different between the short tweet and the long note tweet

        let expandedEscapedTweetText = expandUrls(escapedTweetText,tweet.entities.urls,"url","display_url","expanded_url");


        //const expandedEscapedTweetTextWithoutTrailingElipsis = removeTrailingChar(expandedEscapedTweetText, "…");
        
        // Preprocess the mentions so they are in normalized form
        let mentions = [];
        if (tweet.entities && tweet.entities.user_mentions && tweet.entities.user_mentions.length > 0) {
          mentions = tweet.entities.user_mentions;
        }

        // Ok the text from the short tweet is now normalized and ready for comparison and inclusion in the final HTML output
        // We add a sequence number that preserves the orginal order in the file so that we can break ties if two tweets have the same timestamp. 
        tweetsWorkingRecords.push({
          "normalizedText": expandedEscapedTweetText,   // Note that this still has the elipses at the end since we do not know that was added by twitter or actually part of the tweet entered by the user (I tested and you can end a tweet with an elipses https://x.com/bigjoshlevine/status/1879368393918451727)  
          "timestamp": new Date(tweet.created_at), 
          "media": media,      
          "mentions": mentions,
          "sequence": tweetcount,
          "tweet": tweet,             // Save the orginal tweet for stuff like replyto
        });

        tweetcount++;

      });

      // Now we have a nice list tweets in the tweetsWorkingRecords array with normalized text, timestamp, media, and mentions. Everything we need to emit the final output.

      // NOW IS A GOOD TIME TO SORT THE TWEETS 

      // We sort the tweets by date, oldest first.
      // This makes displaying tweetstorms more natural, and also maybe better for SEO?
      // If you invert the sort order then you might want to change the localLinkIndicator to a down arrow

      // It seems that tweetstorms all get the same timestamp, so we use the sequence number to break ties

      updateProgressMessage("Sorting tweets...");

      const sortedTweetWorkingRecords = tweetsWorkingRecords.sort((a, b) =>  {

        // If two tweets have the same timestamp, the one that came earlier in the tweet.js file should come first
        if (a.timestamp.getTime() === b.timestamp.getTime()) {
          return b.sequence - a.sequence;  // Highest sequnce first since threaded tweets come in inverse order int tweets.js
        }

        // When tweets have the same timestamp, the one that came highest in the orginal tweets.js file first
        return a.timestamp.getTime() - b.timestamp.getTime();     

      });


      // Now that both notes and tweets text have been normalized, we can start comparing them to find matches
      // If we find a match, then we replace the normalized text in tweetsworkingrecords with the normalized text from the note
      // and remove the note from the notesWorkingRecordsSet so we do not try to use it twice. 


      // Checking to see if there is a note that matches this tweet is hard. There is no hard link between them, so we have to do a 
      // fuzzy match. 

      // First we check to get all of the notes that have the same timestamp as the tweet, but nust having a matching timestamp
      // is not enough becuase multipule tweets can have the same timestamp, so we also need to check to see if the text of the note
      // matches the cleaned text of the tweet. Even this is not enough becuase there could be multiple tweets with the same timestamp
      // and matching short text, but the long text of the note could be different. To deal with this very edge case, we keep a set of which
      // notes have been matched and then only use notes that have not been matched.

      // All this may seam like overkill, but it ensures that the worst mismatch that can happen is that we match the wrong note to the wrong tweet
      // within the same tweetstorm, so net effect is that the long tweets ar ein the wrong order - and this is a very edge case of a tweetstorm
      // where there is a maximum length short tweet and a long tweet that begins the exact same way as he short tweet but is longer.

    
      // OK now we can go looking to see if there is an unused note that matches this tweet's (1) timestamp and (2) leading text
      // If we find a match, then we add a new property called `note` to the record in tweetsWorkingRecords so that we can use it in the final HTML
      // We also remove the note from the set so we do not try to use it again.

      // UPDATE: It turns out that the timestamps on a tweet and its corresponding note tweet are not always the same! Arggggghh!
      //         So now we will have to first filter all text matches, and then pick theone that is closest in time.
      
      tweetsWorkingRecords.forEach( tweetRecord => {

        // Remember that the short tweet will still have a trailing elipses if it is a note tweet since we do not know if that was added by 
        // twitter or actually part of the tweet entered by the user (I tested and you can end a tweet with an elipses https://x.com/bigjoshlevine/status/1879368393918451727)  

        let normalizedShortTweetTextWithoutTrailingElipsis = removeTrailingChar(tweetRecord.normalizedText, "…");


        // Javascript does not have a Set.filter() method, so we have to do this the old fashioned way


        let matchingTextNotes = [];
        
        notesWorkingRecordsSet.forEach( noteRecord => {

          // We compare the (already normalized) leading text of the note to the (already normalized) leading text of the short tweet - but we have to remove the trailing ... from the short tweet
          if ( noteRecord.normalizedText.startsWith(normalizedShortTweetTextWithoutTrailingElipsis) ) {
            matchingTextNotes.push(noteRecord);
          }
        });

        // Now matchingTextNotes is an array of note records that have the same leading text as the short tweet. We need to find the one that is closest in time.

        if (matchingTextNotes.length > 0) {

          const bestMatchingNoteRecord = matchingTextNotes.reduce(( bestMatchingNoteRecordSoFar, currentNoteRecord ) => {
            if ( Math.abs(currentNoteRecord.timestamp.getTime() - tweetRecord.timestamp.getTime()) < Math.abs(bestMatchingNoteRecordSoFar.timestamp.getTime() - tweetRecord.timestamp.getTime()) ) {
              return currentNoteRecord;
            } else {
              return bestMatchingNoteRecordSoFar;
            }
          });

          // We found a match so add the note to the tweet record
          tweetRecord.normalizedNoteText = bestMatchingNoteRecord.normalizedText;

          // Remove the note from the set so we do not try to use it again
          notesWorkingRecordsSet.delete(bestMatchingNoteRecord);

        }        

      }); 

      // Build the final HTML    

      let html = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8" />
          <title>My Exported ${tweets.length} Tweets</title>
          <style>
            body {
              margin: 2rem auto;
              max-width: 600px;
              font-family: sans-serif;
              line-height: 1.4;
              background: #f9f9f9;
            }
            .container {
              background: #fff;
              margin-top: 1rem;
              margin-bottom: 1px;
              padding: 1rem;
              border: 1px solid #ddd;
              border-radius: 8px;
            }
            .container.thread-tweet {                   /* Visually make thread connect to the tweet above them */
              margin-top: 1px;
              border-top: none;         
              border-top-left-radius: 0;
              border-top-right-radius: 0;
            }
            .media-grid {
              display: grid;
              grid-gap: 2px;
              margin: 0.5rem 0;
              border-radius: 8px;
              overflow: hidden;
            }
            .media-grid.grid-2 {
              grid-template-columns: repeat(2, 1fr);
            }
            .media-grid.grid-3 {
              grid-template-columns: repeat(2, 1fr);
            }
            .media-grid.grid-3 .media-item:first-child {
              grid-column: span 2;
            }
            .media-grid.grid-4 {
              grid-template-columns: repeat(2, 1fr);
            }
            .media-item {
              position: relative;
              overflow: hidden;
            }
            .media-item a {
              display: block;
              width: 100%;
              height: 100%;
            }
            .media-item a:hover {
              opacity: 0.9;
            }
            .media-item img,
            .media-item video {
              width: 100%;
              height: auto;
              object-fit: cover;
              display: block;
            }

            .reply-info {
              font-size: 0.85rem;
              color: #555;
              margin-bottom: 0.5rem;
            }
            .reply-info a {
              color: #1da1f2;
              text-decoration: none;
            }
            .header {
              font-size: 0.85rem;
              margin-bottom: 1rem;
              display: flex;
              justify-content: space-between;
              border-bottom: 1px solid #a0a0fa;
              padding: 0.5rem;
              border-radius: 8px 8px 0 0;
            }
            .date {
            }
            .id {
              color: rgb(83, 100, 113);
            }
            .text {
              margin-bottom: 0.5rem;
              white-space: pre-wrap;
            }
            .mentions {
              margin-top: -0.5rem;
              margin-bottom: 1rem;
              font-size: 0.9rem;
              color: #536471;
            }
            .mentions table {
              border-collapse: collapse;
            }
            .mentions td {
              padding: 0.2rem 1rem 0.2rem 0;
            }
            .mentions a {
              text-decoration: none;
              color: #1DA1F2;
            }
            .mentions a:hover {
              text-decoration: underline;
            }
            code {
              white-space: nowrap;
              background-color: #e3f2fd;  /* Light blue background */
              color: #1565c0;            /* Dark blue text */
              padding: 2px 6px;
              border-radius: 4px;
              font-family: 'Consolas', monospace;
            }
          </style>
        </head>
        <body>
          <h1>My Exported Tweets</h1>
      `;

      html +=`Total tweets: ${sortedTweetWorkingRecords.length}<br>`;

      let previousTweetId = null;

      let progressCount = 0;
          
      sortedTweetWorkingRecords.forEach( tweetWorkingRecord => {

        progressCount++;

        updateProgressMessage(`Rendering tweet ${progressCount} of ${tweets.length}`);

        let isThread = false;

        if (tweetWorkingRecord.tweet.in_reply_to_status_id_str && tweetWorkingRecord.tweet.in_reply_to_status_id_str === previousTweetId) {

          // This is a reply to own own tweet that immedeately preceeded this one, 
          // so show as a thread. This visually connects the tweets and also suppresses the "in reply to" line
          isThread = true;

        } 
        html += renderTweet(tweetWorkingRecord,isThread,sortedTweetWorkingRecords);   
        
        // Remeber this tweet so we can check if the next one is a reply to it
        previousTweetId = tweetWorkingRecord.tweet.id_str;

      });

      // I would not expect there to be any unmatched notes, but lets check becuase if there is that means we missed some
      // matching rule. These rules were all emperically found from my own data, so maybe there are others in other people's data

      if (notesWorkingRecordsSet.size > 0) {
        console.log("Remaining notes that were not matched to tweets:", notesWorkingRecordsSet.size);
        console.log(Array.from(notesWorkingRecordsSet));

        html += `<p style="background-color: #fff0f0;">There are ${notesWorkingRecordsSet.size} notes that were not matched to tweets:<br>`

        notesWorkingRecordsSet.forEach(note => {
          html += ` ${note.timestamp.toLocaleString()}: ${note.normalizedText}<br>`;
        });

        updateWarningMessage(`There are ${notesWorkingRecordsSet.size} notes that were not matched to tweets.<br>Please see https://wp.josh.com/2025/01/19/a-utility-to-create-a-static-html-website-from-your-twitter-posts/#mismatched-notes for more info.`);
      }


      html += `<p style="color: rgba(0,0,0,0);">Generated on ${new Date().toLocaleString()} by <a href="https://wp.josh.com/2025/01/19/a-utility-to-create-a-static-html-website-from-your-twitter-posts/" style="color: rgba(0,0,0,0); text-decoration: none;"  >twitter-to-static-html tool</a></p>`;
  
      html += `
        </body>
        </html>
      `;
      return html;
    }

    // For a media in a tweet's extended_entities, this will find the URL that actually coesponds to the media filename that is included in the export (at least for all cases I can check)
    
    function getMediaURL(m) {

      // Check if it's a video 
      if (m.type == 'video' || m.type == 'animated_gif') {

        // animated GIFs seem to be exported as video

        // In the case of video, the file included in the export seems to be the highest quality variant with type video/mp4

        const maxVariant = m.video_info.variants.filter(variant => variant.content_type === 'video/mp4').reduce((highest, current) => {
            if (!current.bitrate) showError("Missing bitrate in video variant");
            return (parseInt(current.bitrate) > parseInt(highest.bitrate)) ? current : highest;
        });

        // Extract filename from URL
        return maxVariant.url;

      } else if (m.type == 'photo') {

        // Extract filename from URL
        return m.media_url_https;

      } else {

        showError(`Unknown media type ${m.type}`);

      }

    }    


    /**
     * Attempts to get a list of media filenames from `extended_entities.media` 
     * Handles both images and videos
     * returns a list of filenames or empty list if no media found
     */

    function getMediaFilenames(media) {
      

      let filenames = [];
    
      media.forEach(m => {

        const url = getMediaURL(m);               // Find the URL that matches to the fiel that was included in the export - different for photos and videos
        const basename = url.split("/").pop();  // Get just part of the url after the last slash
        const mediaFilename = basename.split('?')[0]; // Remove any query parameters    

        filenames.push(mediaFilename);
      })

      /*
      if (tweet.id_str === "864846955343642624") {

        console.log( JSON.stringify(tweet) );
        showError("Thats the one");

      }
      */
    
    return filenames;
  }

  // The filesnames are relative to the mediapath and should not include the tweet id

  function getMediaHtml(tweet,mediapath,mediaFileNames) {
      
      // Add a CSS grid class based on number of media items
      const gridClass = mediaFileNames.length > 1 ? ` grid-${Math.min(mediaFileNames.length, 4)}` : '';
      let mediaHtml = `<div class="media-grid${gridClass}">\n`;

      mediaFileNames.forEach(m => {

          const fullFilename = mediapath + tweet.id_str + "-" + m;
                  
          mediaHtml += `<div class="media-item"><a href="${fullFilename}" target="_blank" rel="noopener noreferrer">`;

            if (m.endsWith('.mp4')) {

            // Browsers will not actually autoplay videos unless they are muted. 

            mediaHtml += `<video autoplay loop muted src="${fullFilename}"></video>`;

          } else {

            // image

            mediaHtml += `<img src="${fullFilename}" loading="lazy" />`;

          } 
            
          mediaHtml += `</a></div>\n`;    // media-item
        });
      
      mediaHtml += '</div>\n';    // media-grid
      return mediaHtml;
    }

    /**
     * Utility: formats the date string into a tweet friendly format
     */

    // TODO: Should we offer the user a way to use zulu times?  

    function formatDate(dateStr) {
      // Show local date/time
      return dateStr.toLocaleString();
    }

    function openHtmlInNewTab(htmlContent) {
      // Create a new Blob with the HTML content
      const blob = new Blob([htmlContent], { type: 'text/html' });

      // Create a URL for the Blob
      const url = URL.createObjectURL(blob);

      // Open a new tab and navigate to the Blob URL
      const newTab = window.open(url, '_blank');

      if (!newTab) {
          alert('Pop-up blocked! Please allow pop-ups for this website.');
      } else {
          // Optionally, revoke the URL once it's loaded to free resources
          newTab.onload = () => URL.revokeObjectURL(url);
      }
  }

  function showError(message) {
    const progressArea = document.getElementById('progress-area');
    const progressMessage = document.getElementById('progress-message');
    progressArea.classList.add('error');
    progressMessage.textContent = message;
    throw new Error(message); // This will terminate execution
  }

  </script>
</body>
</html>

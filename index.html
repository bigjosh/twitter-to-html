<!DOCTYPE html>
<!-- This page is (c) 2025 josh levine [josh.com]. For more info, check out josh.com/2025/01/19/a-utility-to-create-a-static-html-website-from-your-twitter-posts/ -->
<html>
<head>
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
  <meta charset="UTF-8" />
  <title>Twitter Export to Static HTML</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem auto;
      max-width: 640px;
      text-align: center;
    }
    .container {
      border: 1px solid #ccc;
      padding: 1rem;
      background: #f9f9f9;
      border-radius: 8px;
    }
    h1 {
      margin-bottom: 1rem;
    }
    #file-input {
      margin-bottom: 1rem;
    }

    .progress-area {
      margin: 1rem 0;
      border-radius: 4px;
      border: 1px solid #ccc;
      overflow: hidden;
    }
    .progress-header {
      background: #1DA1F2;  /* Twitter's signature blue color */
      color: white;
      padding: 0.5rem 1rem;
      margin: 0;
      font-size: 1rem;
      font-weight: bold;
    }
    .progress-content {
      padding: 1rem;
      background: #f9f9f9;
    }
    .progress-area.error {
      border-color: #ef9a9a;
    }
    .progress-area.error .progress-header {
      background: #c62828;
    }
    .progress-area.error .progress-content {
      background: #ffebee;
      color: #c62828;
    }
    code {
      white-space: nowrap;
      background-color: #e3f2fd;  /* Light blue background */
      color: #1565c0;            /* Dark blue text */
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Consolas', monospace;
    }
    .instructions {
      margin: 1rem 0;
      padding: 0 2rem;
    }
    .instructions ol {
      margin: 0;
      padding-left: 2rem;

    }
    .instructions li {
      margin-bottom: 1rem;
      text-align: left;
    }

  </style>
</head>
<body>
  <div class="container">
    <h1>Twitter Export to Static HTML</h1>
    <p>Read the full article about this tool on <a href="https://wp.josh.com/2025/01/19/a-utility-to-create-a-static-html-website-from-your-twitter-posts/">josh.com</a></p>
    <div class="instructions">
      <ol>
        <li>Click the "Choose Files" button below</li>
        <li>Select the <code>tweets.js</code> and optionally <code>note-tweet.js</code> files from your twitter export. You can select multipule files by holding the control or command key while clicking.</li>
        <li>Wait until the status window says the process is complete</li>
        <li>Click the "Save tweets.html" button to save the newly generated HTML file</li>
      </ol>
    </div>
    <p></p>
    <input type="file" id="file-input" accept=".js" multiple />
    <div id="progress-area" class="progress-area">
      <h3 class="progress-header">Status</h3>
      <div class="progress-content">
        <p id="progress-message"></p>
        <p id="warning-message" style="display: none;"></p>
      </div>
    </div>  

    <!-- Hidden Static link that will be updated dynamically after the HTML has been generated -->
    <p><a id="download-link" href="#" download="tweets.html" style="display: none;">Save your new tweets.html file</a></p>

    <!--- <p><a id="open-link" href="#" target="_blank" style="display: none;">Open in New Tab (note that media will probably not be in the right directory)</a></p> -->

  </div>

  <script>

    // This is the relative path to the media files. This is what it was in my export, but you may need to change it
    // if it is different in your export or you want a different structure on your web server
    // Should include the trailing slash if not empty
    const mediapath = "tweets_media/";

    // Defined in date2string below
    const dateFormat = "YYYY-MM-DD HH:mm:ss";

    // Remeber the progress element so we can update it faster
    const progressMessageText = document.getElementById("progress-message");

    function updateProgressMessage(message) {
      progressMessageText.textContent = message;
    }

    updateProgressMessage("Waiting for files to be selected and processed");


    // Remeber the progress element so we can update it faster
    const progressWarningText = document.getElementById("progress-warning");

    function updateProgressWarningMessage(message) {
      progressWarningText.textContent = message;
    }


    let tweetsContent = null;

    /**
     * Removes `window.YTD... = ` or similar prefix, if present, returning raw JSON text.
     */
    function removeJavaScriptPrefix(content) {
      // Common patterns to remove:
      // e.g. window.YTD.tweets.part0 = [...];
      // You can adapt the regex for other variations
      return content
        .replace(/^window\.YTD\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\s*=\s*/, "") // remove prefix
        .replace(/;\s*$/, ""); // remove trailing semicolon if any
    }


    document.getElementById("file-input").addEventListener("change", async function() {
      const files = Array.from(this.files);
      if (files.length === 0) return;

      try {
        // Find the tweets.js file (required)
        const tweetsFile = files.find(f => f.name.toLowerCase() === 'tweets.js');
        if (!tweetsFile) {
          throw new Error("Please select your tweets.js file");
        }

        // Load main tweets into tweetsArray
        tweetsContent = await tweetsFile.text();

        updateProgressMessage("Loading tweets.js file...");
        tweetsContentCleaned = removeJavaScriptPrefix(tweetsContent);
        tweetsContent = null;   // Free up memory
        let tweetsArray = JSON.parse(tweetsContentCleaned).map( o=> o.tweet );    // Every tweet is in an object called `tweet`, so flatten that out for simplicity
        tweetsContentCleaned = null;  // Free up memory


        // Look for note-tweets.js (optional)
        const noteTweetsFile = files.find(f => f.name.toLowerCase() === 'note-tweet.js');

        let notesArray = [];    // By default we use an empty array rather than undefined so we can operate on it without checking
        let noteCount = 0;

        // Load note tweets if available
        if (noteTweetsFile) {

          updateProgressMessage("Loading note-tweets.js file...");
          const noteContent = await noteTweetsFile.text();
          const noteCleanContent = removeJavaScriptPrefix(noteContent);   // Remove the varabile name at the top of the file so just pure JSON
          notesArray = JSON.parse( noteCleanContent).map( o=> o.noteTweet );    // Every noteTweet is in an object called `noteTweet`, so flatten that out for simplicity            

          // We don't bother sorting the notes since they will end up in a set anyway. This does mean we could scamble the order of notes
          // in the very edge case that two tweets in a tweet storm have the same short version but different long versions. :/
        }


        updateProgressMessage("Generating static HTML...");

        // Generate the static HTML
        const staticHTML = generateStaticHTML(tweetsArray,notesArray);

        updateProgressMessage("Creating download blob...");

        // Create a Blob with the data and generate a Blob URL
        const blob = new Blob([staticHTML], { type: 'text/html' });
        const url = URL.createObjectURL(blob);


        // Update the download link
        const downloadLink = document.getElementById("download-link");
        downloadLink.href = url;    // Set the href attribute of the link to the Blob URL
        downloadLink.style.display = 'inline-block'; // Show the link (was inisible until now)

        /*
        // Update the open link
        const openLink = document.getElementById("open-link");
        openLink.href = url;    // Set the href attribute of the link to the Blob URL
        openLink.style.display = 'inline-block'; // Show the link (was inisible until now)
        */

        updateProgressMessage("Finished. Click the link below to save the newly generated HTML file.");
     
      } catch (err) {
        alert("Error: " + err.message + "\n" + err.stack);
        console.error(err);
        updateProgressMessage("Error: <hr>" + err.message +"<hr>visit <a href=\"https://wp.josh.com/2025/01/19/a-utility-to-create-a-static-html-website-from-your-twitter-posts/#error\" target=\"_blank\">josh.com</a> for more info.");  
      }
    });


    /** Note that tweets and notes escape different chars so we have to handle them seporately. All these had to be found emperically so the list might be longer **/

    /**
     * Escapes HTML special characters in a string
     * The tweets.js already has some chars escaped like ampersand and gt and lt
     * but it does not escape carridge return or quotes.
     * TODO: Are there others?  
     */
    function escapeTweetSpecialCharsToHtml(str) {
      return str
        .replace(/\r?\n/g, '<br>')
        .replace(/"/g, '&quot;');
    }

    /**
     * Escapes HTML special characters in a string
     * The tweets.js already has some chars escaped like ampersand and gt and lt
     * but it does not escape carridge return or quotes.
     * TODO: Are there others?  
     */
     function escapeNoteSpecialCharsToHtml(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\r?\n/g, '<br>')
        .replace(/"/g, '&quot;');
    }

    // Returns an array of tweetRecords that are replies to the tweet 

    function getFollowupRecords(tweetRecord, tweetsWorkingRecords) {

      let followsups = [];

      // For every tweet we have, check if that tweet is a reply to the tweet we are currently processing
      // But do not show as a follow up if that follow up is the next tewwet in a storm since it will visually be right below us anyway. 
      tweetsWorkingRecords.forEach(t => {
        if (
          t.tweet.in_reply_to_status_id_str && 
          t.tweet.in_reply_to_status_id_str === tweetRecord.tweet.id_str &&     // We found a tweet that is a reply to the one we are currently processing
          !(t.tweet.id_str === tweetRecord.nextReplyInStorm)                        // We dont consider the next tweet in a storm to be a followup
        ) {
          followsups.push(t);
        }

      }); 

      return followsups;
    }

    // From https://www.geeksforgeeks.org/how-to-strip-out-html-tags-from-a-string-using-javascript/?ref=ml_lbp

    function removeHTMLTags(str) {
        str = str.toString();

        // Regular expression to identify HTML tags in
        // the input string. Replacing the identified
        // HTML tag with a null string.
        return str.replace(/(<([^>]+)>)/ig, '');
    }

    // Find all internal replies to this tweet and create a list of them
    function getFollowupsHtml(tweetRecord, tweetsWorkingRecords) {

      let html = "";

      let followsups = getFollowupRecords(tweetRecord, tweetsWorkingRecords);

      if (followsups.length > 0) {

        html += `<div class="followups">`;

        // Sort the followups by oldest first
        followsups.sort((a, b) => new Date(a.tweet.createdAt) - new Date(b.tweet.createdAt));

        if (followsups.length > 1) {
          html += "Followups:";
        } else {
          html += "Followup:"; 
        } 

        followsups.forEach(f => {

          const textBlurb = removeHTMLTags(f.normalizedText);   // Make a text-only preview blurb of the tweet 

          // Put in the date and the blurb and make the blurb an anchor link to the tweet
          html += `<div class="followup">${ date2string( f.timestamp , dateFormat )} - <a href="#${f.tweet.id_str}">${textBlurb}</a></div>\r`;
        });


        html += `</div>`; // <div class="followups">
      }

      return html;
    }


    // Expand the shortened URLs in a tweet into their full URLs. Takes the names of the properties becuase
    // tweets and note tweet use differen property names.
    // Assumes urls array exists, which it should in the twitter export, it is empty for tweets with no URLs
    // = expandUrls(escapedTweetText,t.urls,"url","display_url","expanded_url");

    function expandUrls(text,urls,shortUrlProperty,displayUrlProperty,expandedUrlProperty) {

      urls.forEach(url => {
        text = text.replace(url[shortUrlProperty],`<a href="${url[expandedUrlProperty]}" target="_blank">${url[displayUrlProperty]}</a>`); 
      });

      return text;  
    }

    // Helper function to render a single tweet
    // expansion from a short tweet to a long note happens here if there is a matching note
    // We need to provide the full list of tweet so we can localize internal links. 
    function renderTweet(tweetWorkingRecord, tweetsWorkingRecords) {

      const t = tweetWorkingRecord.tweet;      // The orginal tweet object

      // now create the html for the mentions section
      let mentionsHtml = '';
      if (tweetWorkingRecord.mentions.length > 0) {
        mentionsHtml += `<table>\r`;              
        tweetWorkingRecord.mentions.forEach(m => {
          mentionsHtml += ` <tr><td><a href="https://x.com/${m.screen_name}" target="_blank">@${m.screen_name}</a></td><td>${m.name}</td></tr>\r`;              
        });
        mentionsHtml += `</table>\r`;              
      }

      // text now has external embeded URLs expaned and media URLs removed and any trailing spaces removed.

      // Next we build the reply HTML
      const tweetId = t.id_str;
      const tweetUrl = `https://x.com/i/web/status/${tweetId}`;

      // Check if this is a reply tweet
      let replyHtml = '';

      // Suppress the reply to line if this is a followp (so it is obviously a reply to the tweet above it)
      if (t.in_reply_to_status_id_str && !tweetWorkingRecord.isStormReply) {  

        const replyToUrl = `https://x.com/${t.in_reply_to_screen_name}/status/${t.in_reply_to_status_id_str}`;

        // Lets check if this a reply to one of our own tweets that appears above

        let localMatch = tweetsWorkingRecords.find(r => r.tweet.id_str === t.in_reply_to_status_id_str);

        let localLinkHtml = '';

        if (localMatch) {
          const localReplyToUrl = `#${t.in_reply_to_status_id_str}`;   // Local link to the reply tweet. No need to open in new tab
          localLinkHtml = `&nbsp(<a href="${localReplyToUrl}">local copy</a>)`;
        }

        // Link back to the tweet on x.com and inlcude the local link if there is a match
        replyHtml = `In reply to <a href="${replyToUrl}" target="_blank">@${t.in_reply_to_screen_name}/${t.in_reply_to_status_id_str}</a>`+localLinkHtml;
        
      }

      // The meat of the tweet
      let textHTML = '';

      if (tweetWorkingRecord.hasOwnProperty('normalizedNoteText') ) {   // We added `normalizedNoteText` property above in cases where we found a matching note (long form of a tweet )
        textHTML = tweetWorkingRecord.normalizedNoteText;  // Long tweet
      } else {
        textHTML = tweetWorkingRecord.normalizedText;       // Short tweet
      }

      // Next build the media HTML, if any

      const mediaFilenames = getMediaFilenames(tweetWorkingRecord.media);

      let mediaHtml = "";

      // Only bother to include the mdia div is there is any media. 
      if (mediaFilenames.length > 0) {
        
        mediaHtml +=  getMediaHtml(t,mediapath,mediaFilenames);
      }

      // Next add links to any of our internal reples to this tweet (I call them "followups")
      // Goes through all tweets to see which ones are replies to this tweet
      // Automatically suppresses references to "followups" that are the next tweet in a storm

      const followupsHtml = getFollowupsHtml(tweetWorkingRecord, tweetsWorkingRecords);
      

      let headerHtml = "";

      headerHtml += `<div class="tm">\r`; // Top matter
      headerHtml += ` <span class="date">${date2string(tweetWorkingRecord.timestamp,dateFormat)}</span>\r`;
      headerHtml += ` <span class="id"><a href="${tweetUrl}" target="_blank">ID=${tweetId}</a></span>\r`;
      headerHtml += `</div>\r`;


      // ===== Finally we will build up the final html for the tweet so we can return it. 

      let tweetHTML = "";

      let className = "tweet";

      if (tweetWorkingRecord.isStormReply) {
        className += " storm-reply";              // Decorate strom replies so they vistually nestle into the tweet above they are in reply to
      } 

      tweetHTML += `<div class="${className}" id="${tweetId}">\r`;      // Putting the ID here lets us deep link to a specific tweet by adding # in front of the ID  

      tweetHTML += ` ` +headerHtml;

      if (replyHtml) {
        tweetHTML += `<div class="reply">${replyHtml}</div>\r`;  
      }

      if (mentionsHtml) {  
        tweetHTML += `<div class="mentions">${mentionsHtml}</div>\r`;  
      }

  
      tweetHTML += `<div class="text">${textHTML}</div>\r`;

      if (mediaHtml) {
        tweetHTML += `<div class="media">${mediaHtml}</div>\r`;
      }

      tweetHTML += followupsHtml;       // This will be empty if there are no followups

      tweetHTML += `</div>\r`;    // Close container

      return tweetHTML;

    }


    function removeTrailingCharIfPresent(str, charToRemove) {
      if (str.endsWith(charToRemove)) {
          return str.slice(0, -1);
      }
      return str;
    }


    function date2string(date, format) {
      const pad = n => n.toString().padStart(2, '0');
      const h = date.getHours();
      const replacements = {
        'YYYY': date.getFullYear(),
        'MM': pad(date.getMonth() + 1),
        'DD': pad(date.getDate()),
        'HH': pad(h),
        'hh': pad(h % 12 || 12),
        'mm': pad(date.getMinutes()),
        'ss': pad(date.getSeconds()),
        'AP': h < 12 ? 'AM' : 'PM'
      };
        
      return format.replace(/YYYY|MM|DD|HH|hh|mm|ss|AP/g, match => replacements[match]);
    }    

    function foldMatchingNoteRecordsIntoTweetRecords(tweetRecords,noteRecordSet) {
    }

    /**
     * Generates a complete static HTML document from an array of tweet objects.
     * This HTML contains no JavaScript and references images in the `tweets_media` folder.
     * If no notes, then pass an empty array.
     * It is very hard to match tweets with notes.
     */


    function generateStaticHTML(tweets,notes) {

      // It looks like embeded URLs are different between the two versions of the tweet, so we need to expand them before comparing them. Urgh. 
      // They also use different escapeing functions, so we will have to normalize the texts before we can try finding matches.
      // tweets: "full_text" : "Sadly it seams that https://t.co/QKpprngYYE leaked my email address (and probably yours) to spammers.\n#surprisingspam\n\nHow I know:\nhttps://t.co/6m5GQ8IPHS\n\n(Interestingly, GMAIL silently ghosted this spam.  It is good that they correctly classified it as spam, but it is scary… https://t.co/gQcv8kzM4D",
      // notes: "text"       : "Sadly it seams that https://t.co/XVzYx757Tu leaked my email address (and probably yours) to spammers.\n#surprisingspam\n\nHow I know:\nhttps://t.co/bzKbdOkkrX\n\n(Interestingly, GMAIL silently ghosted this spam.  It is good that they correctly classified it as spam, but it is scary that they think it is ok to accept an email and then completely erase any record that it ever existed. Beware.)",

      // Make a set of notes since we can only use each note once. This will also make it faster to look the notes up.
      let notesWorkingRecords = [];

      // We pre-exapand all the URLs notes so we can search on them (the tiny URLs are different between the short tweet and the long note tweet)
      // We have to escape the special chars for HTML first before we can expand the URLs becuase they will have HTML in them. 
      // Note that there are no media URLs or replyto @users in notes
      // Text text is called `text` in notes and `full_text` in tweets

      updateProgressMessage("Expanding URLs in notes.");
      
      notes.forEach( note => {

        //console.log("Note time: " + new Date(note.createdAt));

        const noteText = note.core.text ?? "";      // I've never seen a note without text, but there are tweets without a text property so...

        // We have to escape the special chars for HTML first before we can expand the URLs becuase they will have HTML in them.
        // but anoyingly tweets and notes have different special chars that are preexpanded so we have to handle them seporately
        const escapedNoteText = escapeNoteSpecialCharsToHtml(noteText);    
        
        // ANd now we can expand all the URLs. We have to do this becuase the tiny URLs are different between the short tweet and the long note tweet

        const expandedAndEscapedNoteText = expandUrls(escapedNoteText, note.core.urls, "shortUrl", "displayUrl", "expandedUrl");

        //console.log("Note out : " + noteText); 
      
        notesWorkingRecords.push({
          "normalizedText": expandedAndEscapedNoteText,
          "timestamp": new Date(note.createdAt)
        });
      });


      // Next for all tweets lets remove leading @mentions, media URLS, and escape special chars and then expand all the URLS 
      // Once this is done, then the text in the tweets and notes will at least be in the same format

      let tweetcount = 0;

      // Working set of tweets used inside generateStaticHTML()
      // we modify this to match notes up with the tweets by adding a new property `normalizedNoteText`
      let tweetsWorkingRecords = [];      
      
      tweets.forEach( tweet => {  

        // Starting point is the full text of the tweet

        let text = tweet.full_text ?? "";     // If a tweet only has media then the full_text is missing

        // First we strip all of the media URLs from the short tweet since they do not appear in the long note tweet
        // We will add the media into the output HTML later. 

        let media = [];   // If there are no media in this tweet, we will get an emptry arroy to iterate through
                          // This will be saved in tweetWorkingRecords so we can add the media items back to the HTML later

        if (tweet.extended_entities && tweet.extended_entities.media) {  
          media = tweet.extended_entities.media;        
        
          const mediaUrls = new Set();

          // Make a set of all media URLs
          media.forEach(m => {
            text = text.replace(m.url, '');   // Remove media URLs from text
          });

          // Trim any extra whitespace that might be left after removing URLs
          text = text.trim();
        }

        // Text is now the short tweet with media URLs removed
        
        // Next remove any leading mentions. We will add them as a different element from the usermentions array in entities. 
        // Not only do they look ugly at the begining there, they will also break our ability to find this tweet in notetweets
        // No need to save them becuase they are redundantly also stored in entities.user_mentions

        while (text.startsWith('@')) {
          // Find the end of the username (space or end of string)
          let spaceIndex = text.indexOf(' ');
          if (spaceIndex === -1) {
              text = '';  // If no space found, the entire text is a mention
              break;
          } else {
            // Skip the mention and the following space
            text = text.slice(spaceIndex + 1);
          }
        }

        // But since we are going to expand the URLs, we will also need to escape out the HTML special chars before we can expand the URLs becuase they will have HTML in them. 

        let escapedTweetText = escapeTweetSpecialCharsToHtml(text);    
        
        // Now we can expand all the embeded URLs. We have to do this becuase the tiny URLs are different between the short tweet and the long note tweet

        let expandedEscapedTweetText = expandUrls(escapedTweetText,tweet.entities.urls,"url","display_url","expanded_url");


        //const expandedEscapedTweetTextWithoutTrailingElipsis = removeTrailingChar(expandedEscapedTweetText, "…");
        
        // Preprocess the mentions so they are in normalized form
        let mentions = [];
        if (tweet.entities && tweet.entities.user_mentions && tweet.entities.user_mentions.length > 0) {
          mentions = tweet.entities.user_mentions;
        }

        // Ok the text from the short tweet is now normalized and ready for comparison and inclusion in the final HTML output
        // We add a sequence number that preserves the orginal order in the file so that we can break ties if two tweets have the same timestamp. 
        tweetsWorkingRecords.push({
          "normalizedText": expandedEscapedTweetText,   // Note that this still has the elipses at the end since we do not know that was added by twitter or actually part of the tweet entered by the user (I tested and you can end a tweet with an elipses https://x.com/bigjoshlevine/status/1879368393918451727)  
          "timestamp": new Date(tweet.created_at), 
          "media": media,      
          "mentions": mentions,
          "sequence": tweetcount,
          "tweet": tweet,             // Save the orginal tweet for stuff like replyto
        });

        tweetcount++;

      });

      console.log("Found " + tweetcount + " tweets.");

      // Now we have a nice list tweets in the tweetsWorkingRecords array with normalized text, timestamp, media, and mentions. Everything we need to emit the final output.

      // --- The hard problem of match notes to tweets is here ---
      // I'd like to break this into a function, but it mus modify the tweetsWorkingRecords array so not a good idea

      // Now that both notes and tweets text have been normalized, we can start comparing them to find matches
      // If we find a match, then we replace the normalized text in tweetsworkingrecords with the normalized text from the note
      // and remove the note from the notesWorkingRecordsSet so we do not try to use it twice. 


      // Checking to see if there is a note that matches this tweet is hard. There is no hard link between them, so we have to do a 
      // fuzzy match. 

      // First we check to get all of the notes that have the same timestamp as the tweet, but nust having a matching timestamp
      // is not enough becuase multipule tweets can have the same timestamp, so we also need to check to see if the text of the note
      // matches the cleaned text of the tweet. Even this is not enough becuase there could be multiple tweets with the same timestamp
      // and matching short text, but the long text of the note could be different. To deal with this very edge case, we keep a set of which
      // notes have been matched and then only use notes that have not been matched.

      // All this may seam like overkill, but it ensures that the worst mismatch that can happen is that we match the wrong note to the wrong tweet
      // within the same tweetstorm, so net effect is that the long tweets ar ein the wrong order - and this is a very edge case of a tweetstorm
      // where there is a maximum length short tweet and a long tweet that begins the exact same way as he short tweet but is longer.

    
      // OK now we can go looking to see if there is an unused note that matches this tweet's (1) timestamp and (2) leading text
      // If we find a match, then we add a new property called `note` to the record in tweetsWorkingRecords so that we can use it in the final HTML
      // We also remove the note from the set so we do not try to use it again.
      

      // UPDATE: It turns out that the timestamps on a tweet and its corresponding note tweet are not always the same! Arggggghh!
      //         So now we will have to first filter all text matches, and then pick theone that is closest in time.

      // UPDATE: Turns out there are notes that are empty and tweets that are empty which makes matching harder.
      //         New strategy is to sort both notes and tweet by text length + timestamp so that we get the longest text first and oldest first with ties.
      //         The we can scan down the notes in this order and look for the longest then oldest matching tweet.

      let notesWorkingRecordsSoretedLongestOldestFirst = notesWorkingRecords.sort( (a,b) => {
        if (a.normalizedText.length === b.normalizedText.length) {
          return a.timestamp - b.timestamp;
        } else {
          return b.normalizedText.length - a.normalizedText.length;
        }
      });

      // This is not const becuase we will remove matched tweets from this list as we go 
      // we have to use `from` becuase javascript array.sort apparently sorts records in place(!) and returns the original array. wtf js. 
      let tweetsWorkingRecordsSortedLongestOldestFirst = Array.from(tweetsWorkingRecords).sort( (a,b) => {
        if (a.normalizedText.length === b.normalizedText.length) {
          return a.timestamp - b.timestamp;
        } else {
          return b.normalizedText.length - a.normalizedText.length;
        }
      }); 


      // Tries tofind the best matching tweet, or returns null if no tweet matches
      // sortedTweetsRecords should be in order from longest to shortest, and inside each length the oldest first

      function findBestMatchingTweetRecord(noteRecord,sortedTweetsRecords) {
        
        // Scan though all tweets still in the list
        sortedTweetsRecords.forEach( tweetRecord => {


          //console.log(  `checking tweet ${tweetRecord.normalizedText.length}: `+ JSON.stringify(tweetRecord) );

          // Remove the trailing "..." from the text if present because the note will not have it. 
          const normalizedShortTweetTextWithoutTrailingElipsis = removeTrailingCharIfPresent(tweetRecord.normalizedText, "…");

          // if (tweetRecord.normalizedText.includes("photobombs")) {
          //   console.log("note :" + noteRecord.normalizedText);
          //   console.log("norml:" + normalizedShortTweetTextWithoutTrailingElipsis);
          //   console.log("reslt:" + noteRecord.normalizedText.startsWith(normalizedShortTweetTextWithoutTrailingElipsis) );
          // }

          //console.log( "note :" + noteRecord.normalizedText );
          //console.log( "tweet:" + normalizedShortTweetTextWithoutTrailingElipsis );

          if (noteRecord.normalizedText.startsWith(normalizedShortTweetTextWithoutTrailingElipsis) ) {

            // console.log("match");
          
            // We found a match for this note.
            return tweetRecord;

          }

        });

        // console.log("no match");

        // No match found. This is kinda wierd 
        return null;
      }

      // Scan though each note and try to find the best matching tweet      

      notesWorkingRecordsSoretedLongestOldestFirst.forEach( noteRecord => {

        // if (noteRecord.normalizedText.includes("photobombs")) {
        //   console.log(  `note :${noteRecord.normalizedText}` );
        // }

        const bestMatchingTweetRecord = findBestMatchingTweetRecord(noteRecord,tweetsWorkingRecordsSortedLongestOldestFirst);

        if (bestMatchingTweetRecord) {

            // if (noteRecord.normalizedText.includes("photobombs")) { 
            //   console.log(`tweet: ${bestMatchingTweetRecord.normalizedText}`);
            // }
            //console.log(  `Found matching tweet ${bestMatchingTweetRecord.normalizedText.length}: `+ JSON.stringify(bestMatchingTweetRecord) );

            // Do a sanity check just to try to protect against the case where a note has not real matching tweet
            // so it ends up matching with a tweet that is short enough that the begiing of the tweet is the same as the note.
            // This can happen trivially becuase tweets can have zero length.

            const timeDistance = Math.abs(noteRecord.timestamp.getTime() - tweetRecord.timestamp.getTime());

            if (timeDistance > 86400000) {    // One day in milliseconds
              alert(`tweet ${noteRecord.tweet.id_str} more than a day away from note ${bestMatchingTweetRecord.tweet.id_str}`);
              console.log(  `matching tweet more than a daya away from the note`);
              console.log(  `timeDistance: ${timeDistance} `);
              console.log(  `note ${noteRecord.normalizedText.length}: `+ JSON.stringify(noteRecord) );
              console.log(  `tweet ${tweetRecord.normalizedText.length}: `+ JSON.stringify(bestMatchingTweetRecord) );
            }                        

          // Add the note text to the matching tweet
          bestMatchingTweetRecord.normalizedNoteText = noteRecord.normalizedText;

          // Remove the matching tweet from the list so we do not try to use it again
          bestMatchingTweetRecord.matchedNote = noteRecord;
          tweetsWorkingRecordsSortedLongestOldestFirst.splice(tweetsWorkingRecordsSortedLongestOldestFirst.indexOf(bestMatchingTweetRecord), 1);

        } else {
          // TODO: Make this a warning

          // if (noteRecord.normalizedText.includes("photobombs")) {
          //   console.log(  `=Nomatch`); 
          // }
        }

      });

      //  free up the list we used for matching since they are not used anymore
      tweetsWorkingRecordsSortedLongestOldestFirst.length = 0;  // Clear the array
      tweetsWorkingRecordsSortedLongestOldestFirst = null;      // Remove the reference
      notesWorkingRecordsSoretedLongestOldestFirst.length = 0;  // Clear the array
      notesWorkingRecordsSoretedLongestOldestFirst = null;      // Remove the reference

      // When we get here, every note should have been assigned to the best matching tweet. 

      // OK, now all notes have been matched to their best tweet

      // NOW IS A GOOD TIME TO SORT THE TWEETS FOR DISPLAY

      // We sort the tweets by date, oldest first.
      // This makes displaying tweetstorms more natural, and also maybe better for SEO?
      // If you invert the sort order then you might want to change the localLinkIndicator to a down arrow

      // It seems that tweetstorms all get the same timestamp, so we use the sequence number to break ties

      updateProgressMessage("Sorting ${tweetsWorkingRecords.length} tweets...");

      const sortedTweetWorkingRecords = tweetsWorkingRecords.sort((a, b) =>  {

        // If two tweets have the same timestamp, the one that came earlier in the tweet.js file should come first
        if (a.timestamp.getTime() === b.timestamp.getTime()) {
          return b.sequence - a.sequence;  // Highest sequnce first since threaded tweets come in inverse order int tweets.js
        }

        // When tweets have the same timestamp, the one that came highest in the orginal tweets.js file first
        return a.timestamp.getTime() - b.timestamp.getTime();     

      });

      // Finally lets mark all tweets that are part of a tweetstorm (consecutive replies to our own tweet) so
      // that we can condense these visually. 

      let prevTweetWorkingRecord = null;

      sortedTweetWorkingRecords.forEach( (t) => {

        if(t.tweet.in_reply_to_status_id_str && t.tweet.in_reply_to_status_id_str === prevTweetWorkingRecord.tweet.id_str) {

          t.isStormReply = true;    
          prevTweetWorkingRecord.nextReplyInStorm = t.tweet.id_str;

        }

        prevTweetWorkingRecord = t;

      });
    
      // Build the final HTML     

      let html = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8" />
          <title>My Exported ${tweets.length} Tweets</title>
          <style>
            body {
              margin: 2rem auto;
              max-width: 600px;
              font-family: sans-serif;
              line-height: 1.4;
              background: #f9f9f9;
            }
            .tweet {
              background: #fff;
              margin-top: 1rem;
              margin-bottom: 1px;
              padding: 1rem;
              border: 1px solid #ddd;
              border-radius: 8px;
            }

            .tweet.storm-reply {                   /* Visually make thread connect to the tweet above them */
              margin-top: 1px;
              border-top: none;         
              border-top-left-radius: 0;
              border-top-right-radius: 0;
            }

            /* Media container */

            .cm {
              width: 100%;
              background: #b9b9b9;  
              border-radius: 8px;
              border: 1px solid #a0a0fa;
              box-sizing: border-box; 
              aspect-ratio: 1 / 1; /* Keeps the bounding box square */
              overflow: hidden; /* Ensures the image doesn't overflow the bounding box */
              position: relative; /* Ensures child elements can be positioned relative to this */
            }            

            .cm img, .cm video  {
              width: 100%;
              height: 100%;
              object-fit: contain; /* Scales the image to fit inside while maintaining aspect ratio */
              object-position: center; /* Centers the image within the box */
            } 


            .reply {
              font-size: 0.85rem;
              color: #555;
              margin-bottom: 0.5rem;
            }
            .reply a {
              color: #1da1f2;
              text-decoration: none;
            }

            /* Top Matter */
            .tm {
              font-size: 0.85rem;
              margin-bottom: 1rem;
              display: flex;
              justify-content: space-between;
              border-bottom: 1px solid #a0a0fa;
              padding: 0.5rem;
              border-radius: 8px 8px 0 0;
            }
            .date {
            }
            .id {
              color: rgb(83, 100, 113);
            }
            .text {
              margin-bottom: 0.5rem;
              white-space: pre-wrap;
            }
            .mentions {
              margin-top: -0.5rem;
              margin-bottom: 1rem;
              font-size: 0.9rem;
              color: #536471;
            }
            .mentions table {
              border-collapse: collapse;
            }
            .mentions td {
              padding: 0.2rem 1rem 0.2rem 0;
            }
            .mentions a {
              text-decoration: none;
              color: #1DA1F2;
            }
            .mentions a:hover {
              text-decoration: underline;
            }

            .followups {
              margin: 1rem 0;
              padding: 0 2rem;
              font-size: 0.85rem;
              color: #555;
            }

            .followup  {
              white-space: nowrap;
              overflow: hidden;
              display: block;

              text-overflow: ellipsis; /* Add ellipsis for overflowed text */
            }

            code {
              white-space: nowrap;
              background-color: #e3f2fd;  /* Light blue background */
              color: #1565c0;            /* Dark blue text */
              padding: 2px 6px;
              border-radius: 4px;
              font-family: 'Consolas', monospace;
            }


          </style>
        </head>
        <body>
          <h1>Exported Tweets</h1>
      `;

      html +=`Total tweets: ${sortedTweetWorkingRecords.length}<br>`;

      let progressCount = 0;
          
      sortedTweetWorkingRecords.forEach( tweetWorkingRecord => {

        progressCount++;

        updateProgressMessage(`Rendering tweet ${progressCount} of ${tweets.length}`);

        html += renderTweet(tweetWorkingRecord,sortedTweetWorkingRecords);         

      });


      html += `<p style="color: rgba(0,0,0,0);">Generated on ${new Date().toLocaleString()} by <a href="https://wp.josh.com/2025/01/19/a-utility-to-create-a-static-html-website-from-your-twitter-posts/" style="color: rgba(0,0,0,0); text-decoration: none;"  >twitter-to-static-html tool</a></p>`;
  
      html += `
        </body>
        </html>
      `;
      return html;
    }

    // For a media in a tweet's extended_entities, this will find the URL that actually coesponds to the media filename that is included in the export (at least for all cases I can check)
    
    function getMediaURL(m) {

      // Check if it's a video 
      if (m.type == 'video' || m.type == 'animated_gif') {

        // animated GIFs seem to be exported as video

        // In the case of video, the file included in the export seems to be the highest quality variant with type video/mp4

        const maxVariant = m.video_info.variants.filter(variant => variant.content_type === 'video/mp4').reduce((highest, current) => {
            if (!current.bitrate) showError("Missing bitrate in video variant");
            return (parseInt(current.bitrate) > parseInt(highest.bitrate)) ? current : highest;
        });

        // Extract filename from URL
        return maxVariant.url;

      } else if (m.type == 'photo') {

        // Extract filename from URL
        return m.media_url_https;

      } else {

        showError(`Unknown media type ${m.type}`);

      }

    }    


    /**
     * Attempts to get a list of media filenames from `extended_entities.media` 
     * Handles both images and videos
     * returns a list of filenames or empty list if no media found
     */

    function getMediaFilenames(media) {
      

      let filenames = [];
    
      media.forEach(m => {

        const url = getMediaURL(m);               // Find the URL that matches to the fiel that was included in the export - different for photos and videos
        const basename = url.split("/").pop();  // Get just part of the url after the last slash
        const mediaFilename = basename.split('?')[0]; // Remove any query parameters    

        filenames.push(mediaFilename);
      })

      /*
      if (tweet.id_str === "864846955343642624") {

        console.log( JSON.stringify(tweet) );
        showError("Thats the one");

      }
      */
    
    return filenames;
  }

  // The filesnames are relative to the mediapath and should not include the tweet id

  function getMediaHtml(tweet,mediapath,mediaFileNames) {
      
      // Add a CSS grid class based on number of media items
      //const gridClass = mediaFileNames.length > 1 ? ` grid-${Math.min(mediaFileNames.length, 4)}` : '';
      let mediaHtml = `<div class="cm">\n`;

      mediaFileNames.forEach(m => {

          const fullFilename = mediapath + tweet.id_str + "-" + m;
                  
          mediaHtml += `<a href="${fullFilename}" target="_blank">`;

            if (m.endsWith('.mp4')) {

            // Browsers will not actually autoplay videos unless they are muted. 

            mediaHtml += `<video autoplay loop muted src="${fullFilename}"></video>`;

          } else {

            // image

            mediaHtml += `<img src="${fullFilename}" loading="lazy" />`;

          } 
            
          mediaHtml += `</a>\n`;    
        });
      
      mediaHtml += '</div>\n';    // cm
      return mediaHtml;
    }

    /**
     * Utility: formats the date string into a tweet friendly format
     */

    // TODO: Should we offer the user a way to use zulu times?  

    function formatDate(dateStr) {
      // Show local date/time
      return dateStr.toLocaleString();
    }

    function openHtmlInNewTab(htmlContent) {
      // Create a new Blob with the HTML content
      const blob = new Blob([htmlContent], { type: 'text/html' });

      // Create a URL for the Blob
      const url = URL.createObjectURL(blob);

      // Open a new tab and navigate to the Blob URL
      const newTab = window.open(url, '_blank');

      if (!newTab) {
          alert('Pop-up blocked! Please allow pop-ups for this website.');
      } else {
          // Optionally, revoke the URL once it's loaded to free resources
          newTab.onload = () => URL.revokeObjectURL(url);
      }
  }

  function showError(message) {
    const progressArea = document.getElementById('progress-area');
    const progressMessage = document.getElementById('progress-message');
    progressArea.classList.add('error');
    progressMessage.textContent = message;
    throw new Error(message); // This will terminate execution
  }

  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Twitter Export to Static HTML</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem auto;
      max-width: 640px;
      text-align: center;
    }
    .container {
      border: 1px solid #ccc;
      padding: 1rem;
      background: #f9f9f9;
      border-radius: 8px;
    }
    h1 {
      margin-bottom: 1rem;
    }
    #file-input {
      margin-bottom: 1rem;
    }
    .textarea-container {
      margin-top: 1rem;
    }
    textarea {
      width: 100%;
      height: 300px;
    }
    .note-tweet-section {
      margin: 1rem 0;
    }
    #note-tweet-input {
      margin: 1rem 0;
      padding: 1rem;
      background: #f0f0f0;
      border-radius: 4px;
    }
    .progress-area {
      margin: 1rem 0;
      padding: 1rem;
      border-radius: 4px;
    }
    .progress-area.error {
      background: #ffebee;
      color: #c62828;
      border: 1px solid #ef9a9a;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Twitter Export to Static HTML</h1>
    <p>Select your <code>tweets.js</code> file and optionally your <code>note-tweets.js</code> file. If you don't include the note-tweets file, any tweets longer than the Twitter max limit will be truncated in the output, but there will be a link to view the full tweet on twitter.com.</p>
    <input type="file" id="file-input" accept=".js,.json" multiple />
    <div id="progress-area" class="progress-area">
      <p id="progress-message"></p>
    </div>

    <div class="textarea-container">
      <p><strong>Generated HTML Output:</strong></p>
      <textarea id="output-textarea" placeholder="Your static HTML will appear here..." readonly></textarea>
    </div>
  </div>

  <!-- Hidden Static link that will be updated dynamically after the HTML has been generated -->
  <a id="download-link" href="#" download="tweets.html" style="display: none;">Download tweets.html File</a>

  <script>

    // This is the relative path to the media files. This is what it was in my export, but you may need to change it
    // if it is different in your export or you want a different structure on your web server
    const mediapath = "data/tweets_media/";


    // Remeber the progress element so we can update it faster
    const progressMessageText = document.getElementById("progress-message");

    function updateProgressMessage(message) {
      progressMessageText.textContent = message;
    }

    updateProgressMessage("Waiting for files to be selected and uploaded");

    let tweetsContent = null;

    /**
     * Removes `window.YTD... = ` or similar prefix, if present, returning raw JSON text.
     */
    function removeJavaScriptPrefix(content) {
      // Common patterns to remove:
      // e.g. window.YTD.tweets.part0 = [...];
      // You can adapt the regex for other variations
      return content
        .replace(/^window\.YTD\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\s*=\s*/, "") // remove prefix
        .replace(/;\s*$/, ""); // remove trailing semicolon if any
    }


    document.getElementById("file-input").addEventListener("change", async function() {
      const files = Array.from(this.files);
      if (files.length === 0) return;

      try {
        // Find the tweets.js file (required)
        const tweetsFile = files.find(f => f.name.toLowerCase() === 'tweets.js');
        if (!tweetsFile) {
          throw new Error("Please select your tweets.js file");
        }

        // Load main tweets into tweetsArray
        tweetsContent = await tweetsFile.text();

        updateProgressMessage("Loading tweets.js file...");
        tweetsContentCleaned = removeJavaScriptPrefix(tweetsContent);
        tweetsContent = null;   // Free up memory
        let tweetsArray = JSON.parse(tweetsContentCleaned).map( o=> o.tweet );    // Every tweet is in an object called `tweet`, so flatten that out for simplicity
        tweetsContentCleaned = null;  // Free up memory

        let tweetCount = 0;

        // lets get the date into a normalized format for all the tweets
        // We also need to add a sequence number so we can keep tweet strorms in thier orginal ordering (they have idential timestamps and the ID numbers are not monotonically increasing)
        tweetsArray.forEach (tweet => {
          tweet.timestamp = new Date(tweet.created_at);        
          tweet.sequence = tweetCount;
          tweetCount = tweetCount + 1;
        });        

        // Look for note-tweets.js (optional)
        const noteTweetsFile = files.find(f => f.name.toLowerCase() === 'note-tweets.js');

        let notesArray = [];    // By default we use an empty array rather than undefined so we can operate on it without checking
        let noteCount = 0;

        // Load note tweets if available
        if (noteTweetsFile) {

          updateProgressMessage("Loading note-tweets.js file...");
          const noteContent = await noteTweetsFile.text();
          const noteCleanContent = removeJavaScriptPrefix(noteContent);   // Remove the varabile name at the top of the file so just pure JSON
          notesArray = JSON.parse( noteCleanContent).map( o=> o.noteTweet );    // Every noteTweet is in an object called `noteTweet`, so flatten that out for simplicity            

          // We don't bother sorting the notes since they will end up in a set anyway. This does mean we could scamble the order of notes
          // in the very edge case that two tweets in a tweet storm have the same short version but different long versions. :/
        }


        // We sort the tweets by date, oldest first.
        // This makes displaying tweetstorms more natural, and also maybe better for SEO?
        // TODO: Should we also delete the `created_at` property as we go to save space?

        // It seems that tweetstorms all get the same timestamp, so we use the sequence number to break ties 

        updateProgressMessage("Sorting tweets...");

        tweetsArray = tweetsArray.sort((a, b) =>  {

          // If two tweets have the same timestamp, the one that came earlier in the tweet.js file should come first
          if (a.timestamp.getTime() === b.timestamp.getTime()) {
            return b.sequence - a.sequence;  // Highest sequnce first since threaded tweets come in inverse order int tweets.js
          }

          // Sort by timestamp, oldest first
          return a.timestamp.getTime() - b.timestamp.getTime();     

        });


        updateProgressMessage("Generating static HTML...");

        // Generate the static HTML
        const staticHTML = generateStaticHTML(tweetsArray,notesArray);

        updateProgressMessage("Creating download blob...");

        // Update the download link
        const downloadLink = document.getElementById("download-link");
        // Create a Blob with the data and generate a Blob URL
        const blob = new Blob([staticHTML], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        downloadLink.href = url;    // Set the href attribute of the link to the Blob URL
        downloadLink.style.display = 'inline-block'; // Show the link (was inisible until now)

        updateProgressMessage("Finished. Click download link above to save.");
     
        // Create an "Open in New Tab" button if it doesn't exist
        let openButton = document.getElementById("open-tab-button");
        if (!openButton) {
          openButton = document.createElement("button");
          openButton.id = "open-tab-button";
          openButton.textContent = "Open in New Tab";
          openButton.onclick = () => openHtmlInNewTab(staticHTML);
          document.getElementById("output-textarea").insertAdjacentElement('afterend', openButton);
        }

      } catch (err) {
        alert("Error: " + err.message + "\n" + err.stack);
        console.error(err);
      }
    });

    /**
     * Escapes HTML special characters in a string
     * The tweets.js already has some chars escaped like ampersand and gt and lt
     * but it does not escape carridge return or quotes.
     * TODO: Are there others?  
     */
    function escapeSpecialCharsToHtml(str) {
      return str
        .replace(/\r?\n/g, '<br>')
        .replace(/"/g, '&quot;');
    }

    // Expand the shortened URLs in a tweet into their full URLs. Takes the names of the properties becuase
    // tweets and note tweet use differen property names.
    // Assumes urls array exists, which it should in the twitter export, it is empty for tweets with no URLs
    // = expandUrls(escapedTweetText,t.urls,"url","display_url","expanded_url");

    function expandUrls(text,urls,shortUrlProperty,displayUrlProperty,expandedUrlProperty) {

      urls.forEach(url => {
        console.log("replace "+url);
        text = text.replace(url[shortUrlProperty],`<a href="${url[expandedUrlProperty]}" target="_blank">${url[displayUrlProperty]}</a>`); 
      });

      return text;  
    }


    /**
     * Generates a complete static HTML document from an array of tweet objects.
     * This HTML contains no JavaScript and references images in the `tweets_media` folder.
     * If no notes, then pass an empty array.
     * Tweets will be exported in the order they are in the array. Notes should be sorted in same order so that they line up with tweets.
     * It is very hard to match tweets with notes, so it is still possible to get them out of order.
     */


    function generateStaticHTML(tweets,notes) {

      // We pre-exapand all the URLs notes so we can search on them (the tiny URLs are different between the short tweet and the long note tweet)
      // We have to escape the special chars for HTML first before we can expand the URLs becuase they will have HTML in them. 
      // Text text is called `text` in notes and `full_text` in tweets
      let notesWorkingRecordsSet = new Set();

      updateProgressMessage("Expanding URLs in notes.");
      
      notes.forEach( note => {
        notesWorkingRecordsSet.add( {
          "text": expandUrls( escapeSpecialCharsToHtml(note.text),note.core.urls,"shortUrl","displayUrl","expandedUrl") ,
          "timestamp": new Date(note.createdAt)     // Precompute this so we can search on it faster
        });
      });

      // Helper function to render a single tweet
      function renderTweet(t, isThread = false) {

        const createdAt = formatDate(t.timestamp);

        // Get the media URLs for this tweet
        // Seams like entities and extended_entities are rendundant? Doesnt matter we are using a set.

        const mediaUrls = new Set();
        if (t.entities && Array.isArray(t.entities.media)) {
          t.entities.media.forEach(m => {
            if (m.url) {
              mediaUrls.add(m.url);
            }
          });
        }
        if (t.extended_entities) {
          if (Array.isArray(t.extended_entities.media)) {
            t.extended_entities.media.forEach(m => {
              if (m.url) {
                mediaUrls.add(m.url);
              }
              // For videos, check the variants in video_info
              if (m.video_info?.variants) {
                m.video_info.variants.forEach(variant => {
                  if (variant.url) {
                    mediaUrls.add(variant.url);
                  }
                });
              }
            });
          }
        }

        // Remove media URLs from text
        // We only need to do this in the short tweet since it seems media is not included in the long note tweet
        let text = t.full_text;

        mediaUrls.forEach(url => {
          text = text.replace(url, '');
        });

        // Trim any extra whitespace that might be left after removing URLs
        text = text.trim();

        // Text is now the short tweet with media URLs removed
        
        // Next remove any leading mentions. We will add them as a different element from the usermentions array in entities. 
        // Not only do they look ugly at the begining there, they will also break our ability to find this tweet in notetweets
        // No need to save them becuase they are redundantly also stored in entities.user_mentions

        while (text.startsWith('@')) {
          // Find the end of the username (space or end of string)
          let spaceIndex = text.indexOf(' ');
          if (spaceIndex === -1) {
              text = '';  // If no space found, the entire text is a mention
              break;
          }
          // Skip the mention and the following space
          text = text.slice(spaceIndex + 1).trimStart();          
        }


        // now create the html for the mentions section
        let mentionsHtml = '';
        if (t.entities && t.entities.user_mentions && t.entities.user_mentions.length > 0) {
          mentionsHtml += `<table>\r`;              
          t.entities.user_mentions.forEach(m => {
            mentionsHtml += ` <tr><td><a href="https://x.com/${m.screen_name}" target="_blank" rel="noopener noreferrer">@${m.screen_name}</a></td><td>${m.name}</td></tr>\r`;              
          });
          mentionsHtml += `</table>\r`;              
        }


        // OK when we get to here, text has the short tweet with leading mentions removed and the trailing media URLs removed.
        // The embded URLs have not yet been expended and special chars have not been escaped.
        // This puts us in a position to check if this is a note tweet and if so replace the text with the note body.

        // Checking to see if there is a note that matches this tweet is hard. There is no hard link between them, so we have to do a 
        // fuzzy match. 
        // First we check to get all of the notes that have the same timestamp as the tweet, but nust having a matching timestamp
        // is not enough becuase multipule tweets can have the same timestamp, so we also need to check to see if the text of the note
        // matches the cleaned text of the tweet. Even this is not enough becuase there could be multiple tweets with the same timestamp
        // and matching short text, but the long text of the note could be different. To deal with this very edge case, we keep a set of which
        // notes have been matched and then only use notes that have not been matched.

        // All this may seam like overkill, but it ensures that the worst mismatch that can happen is that we match the wrong note to the wrong tweet
        // within the same tweetstorm, so net effect is that the long tweets ar ein the wrong order - and this is a very edge case of a tweetstorm
        // where there is a maximum length short tweet and a long tweet that begins the exact same way as he short tweet but is longer.

        // It looks like embeded URLs are different between the two versions of the tweet, so we need to expand them before comparing them. Urgh. 
        // tweets: "full_text" : "Sadly it seams that https://t.co/QKpprngYYE leaked my email address (and probably yours) to spammers.\n#surprisingspam\n\nHow I know:\nhttps://t.co/6m5GQ8IPHS\n\n(Interestingly, GMAIL silently ghosted this spam.  It is good that they correctly classified it as spam, but it is scary… https://t.co/gQcv8kzM4D",
        // notes: "text"       : "Sadly it seams that https://t.co/XVzYx757Tu leaked my email address (and probably yours) to spammers.\n#surprisingspam\n\nHow I know:\nhttps://t.co/bzKbdOkkrX\n\n(Interestingly, GMAIL silently ghosted this spam.  It is good that they correctly classified it as spam, but it is scary that they think it is ok to accept an email and then completely erase any record that it ever existed. Beware.)",

        // But since we are going to expand the URLs, we will also need to escape out the HTML special chars before we do the expantion or else we will loose the links.

        escapedTweetText = escapeSpecialCharsToHtml(text);

        // We can't even use the same code to the the expansion becuase the properties on tweets and notes have different names. :/

        expandedEscaptedTweetText = expandUrls(escapedTweetText,t.entities.urls,"url","display_url","expanded_url");

        function removeTrailingChar(str, charToRemove) {
            if (str.endsWith(charToRemove)) {
                return str.slice(0, -1);
            }
            return str;
        }

        const expandedEscaptedTweetTextWithoutTrailingElipsis = removeTrailingChar(expandedEscaptedTweetText, "…");

        // OK now we can go looking to see if there is an unused note that matches this tweet's (1) timesdtamp and (2) leading text

        let firstMatchingNoteRecord = undefined;
        for (const note of notesWorkingRecordsSet) {
            if (note.timestamp.getTime() === t.timestamp.getTime() && note.text.startsWith(expandedEscaptedTweetTextWithoutTrailingElipsis)) {
                firstMatchingNoteRecord =  note;
                break;  // Exit as soon as we find a match
            }
        }

        if (firstMatchingNoteRecord !== undefined) {
          // We found a note that matches this tweet

          // Replace the text of the tweet with the text of the note
          text = firstMatchingNoteRecord.text;  

          // Remove it from the set so we don't use it again for subsequent tweets
          notesWorkingRecordsSet.delete(firstMatchingNoteRecord);

        }

        // text now has external embeded URLs expaned and media URLs removed and any trailing spaces removed.

        // Next we build the reply HTML
        const tweetId = t.id_str;
        const tweetUrl = `https://x.com/i/web/status/${tweetId}`;

        // Check if this is a reply tweet
        let replyHtml = '';

        // Suppress the reply to line if this is in a thread (so it is obviously a reply to the tweet above it)
        if (t.in_reply_to_status_id_str && !isThread) {  
          const replyUrl = `https://x.com/${t.in_reply_to_screen_name}/status/${t.in_reply_to_status_id_str}`;
          replyHtml = `In reply to <a href="${replyUrl}" target="_blank" rel="noopener noreferrer">@${t.in_reply_to_screen_name}/${t.in_reply_to_status_id_str}</a>`;
        }


        // Next build the media HTML, if any

        const mediaFilenames = getMediaFilenames(t);

        let mediaHtml = "";

        // Only bother to include the mdia div is there is any media. 
        if (mediaFilenames.length > 0) {
          mediaHtml += getMediaHtml(t,mediaFilenames);
        }

        // ===== Finally we will build up the final html for the tweet so we can return it. 

        const threadClass = isThread ? ' thread-tweet' : '';

        let tweetHTML = "";

        tweetHTML += `<div class="tweet-container${threadClass}" id="tweet-${tweetId}">\r`;
        tweetHTML += `  <div class="tweet-time"> <a href="${tweetUrl}" target="_blank" rel="noopener noreferrer">${createdAt}</a> </div>\r`;  

        if (replyHtml) {
          tweetHTML += `  <div class="tweet-reply-info">${replyHtml}</div>\r`;  
        }

        if (mentionsHtml) {  
          tweetHTML += `   <div class="tweet-mentions">${mentionsHtml}</div>\r`;  
        }

        // Here is the beef
        tweetHTML += `   <div class="tweet-text">${expandedEscaptedTweetText}</div>\r`;

        if (mediaHtml) {
          tweetHTML += `   <div class="tweet-media">${mediaHtml}</div>\r`;
        }
        tweetHTML += `</div>\r`;

        return tweetHTML;
      }

      // Build the final HTML    

      let html = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8" />
          <title>My Exported ${tweets.length} Tweets</title>
          <style>
            body {
              margin: 2rem auto;
              max-width: 600px;
              font-family: sans-serif;
              line-height: 1.4;
              background: #f9f9f9;
            }
            .tweet-container {
              background: #fff;
              margin-top: 1rem;
              margin-bottom: 1px;
              padding: 1rem;
              border: 1px solid #ddd;
              border-radius: 8px;
            }
            .tweet-container.thread-tweet {                   /* Visually make thread connect to the tweet above them */
              margin-top: 1px;
              border-top: none;         
              border-top-left-radius: 0;
              border-top-right-radius: 0;
            }
            .tweet-media-grid {
              display: grid;
              grid-gap: 2px;
              margin: 0.5rem 0;
              border-radius: 8px;
              overflow: hidden;
            }
            .tweet-media-grid.grid-2 {
              grid-template-columns: repeat(2, 1fr);
            }
            .tweet-media-grid.grid-3 {
              grid-template-columns: repeat(2, 1fr);
            }
            .tweet-media-grid.grid-3 .media-item:first-child {
              grid-column: span 2;
            }
            .tweet-media-grid.grid-4 {
              grid-template-columns: repeat(2, 1fr);
            }
            .media-item {
              position: relative;
              overflow: hidden;
            }
            .media-item a {
              display: block;
              width: 100%;
              height: 100%;
            }
            .media-item a:hover {
              opacity: 0.9;
            }
            .media-item img {
              width: 100%;
              height: auto;
              object-fit: cover;
              display: block;
            }
            .tweet-reply-info {
              font-size: 0.85rem;
              color: #555;
              margin-bottom: 0.5rem;
            }
            .tweet-reply-info a {
              color: #1da1f2;
              text-decoration: none;
            }
            .tweet-time {
              color: rgb(83, 100, 113);
              font-size: 0.85rem;
              margin-bottom: 0.5rem;
            }
            .tweet-text {
              margin-bottom: 0.5rem;
              white-space: pre-wrap;
            }
            .tweet-link a {
              font-size: 0.85rem;
              color: #1da1f2;
              text-decoration: none;
            }
            .tweet-mentions {
              margin-top: -0.5rem;
              margin-bottom: 1rem;
              font-size: 0.9rem;
              color: #536471;
            }
            .tweet-mentions table {
              border-collapse: collapse;
            }
            .tweet-mentions td {
              padding: 0.2rem 1rem 0.2rem 0;
            }
            .tweet-mentions a {
              text-decoration: none;
              color: #1DA1F2;
            }
            .tweet-mentions a:hover {
              text-decoration: underline;
            }
          </style>
        </head>
        <body>
          <h1>My Exported Tweets</h1>
      `;

      html +=`Total tweets: ${tweets.length}<br>`;

      previousTweetId = null;

      let progressCount = 0;

      tweets.forEach(tweet => {

        progressCount++;

        updateProgressMessage(`Rendering tweet ${progressCount} of ${tweets.length}`);


        if (tweet.in_reply_to_status_id_str && tweet.in_reply_to_status_id_str === previousTweetId) {
            // This is a reply to own own tweet that immedeately preceeded this one, 
            // so show as a thread. This visually connects the tweets and also suppresses the "in reply to" line
            isThread = true;
        } else {
          isThread=false;        
        }

        html += renderTweet(tweet,isThread);   
        
        // Remeber this tweet so we can check if the next one is a reply to it
        previousTweetId = tweet.id_str;

      });
  
      html += `
        </body>
        </html>
      `;
      return html;
    }


    // For a media in a tweet's extended_entities, this will find the URL that actually coesponds to the media filename that is included in the export (at least for all cases I can check)
    
    function getMediaURL(m) {

      // Check if it's a video 
      if (m.type == 'video' || m.type == 'animated_gif') {

        // animated GIFs seem to be exported as video

        // In the case of video, the file included in the export seems to be the highest quality variant

        console.log("m", JSON.stringify(m));

        const maxVariant = m.video_info.variants.filter(variant => variant.content_type === 'video/mp4').reduce((highest, current) => {
            if (!current.bitrate) showError("Missing bitrate in video variant");
            console.log("current", JSON.stringify(current), "highest", JSON.stringify(highest));
            return current.bitrate > highest.bitrate ? current : highest;
        });

        console.log("maxVariant", JSON.stringify(maxVariant));

        // Extract filename from URL
        return maxVariant.url;

      } else if (m.type == 'photo') {

        // Extract filename from URL
        return m.media_url_https;

      } else {

        showError(`Unknown media type ${m.type}`);

      }

    }    


    /**
     * Attempts to get a list of media filenames from `extended_entities.media` 
     * Handles both images and videos
     * returns a list of filenames or empty list if no media found
     */

    function getMediaFilenames(tweet) {
      
      // Check extended_entities first as it contains the full media info
      if (!tweet.extended_entities || !tweet.extended_entities.media) {  
        return [];
      } 


      let filenames = [];

      const media = tweet.extended_entities.media;


    
      media.forEach(m => {

        const url = getMediaURL(m);               // Find the URL that matches to the fiel that was included in the export - different for photos and videos
        const basename = url.split("/").pop();  // Get just part of the url after the last slash
        const mediaFilename = basename.split('?')[0]; // Remove any query parameters    

        filenames.push(`${tweet.id_str}-${mediaFilename}`);
      })

      /*
      if (tweet.id_str === "864846955343642624") {

        console.log( JSON.stringify(tweet) );
        showError("Thats the one");

      }
      */
    
    return filenames;
  }


function getMediaHtml(tweet,mediaFileNamefileNames) {
      
      // Add a CSS grid class based on number of media items
      const gridClass = mediaFileNamefileNames.length > 1 ? ` grid-${Math.min(mediaFileNamefileNames.length, 4)}` : '';
      let mediaHtml = `<div class="tweet-media-grid${gridClass}">\n`;

      mediaFileNamefileNames.forEach(m => {
                  
          mediaHtml += `
            <div class="media-item">
            <a href="${mediapath}${m}" target="_blank" rel="noopener noreferrer">
              <img src="${mediapath}${m}" 
                  alt="Tweet media" 
                  style="width: 100%; height: auto;"
                  loading="lazy" />
            </a>
          </div>\n`;
        });
      
      mediaHtml += '</div>';
      return mediaHtml;
    }

    /**
     * Utility: formats the date string into a tweet friendly format
     */

    // TODO: Should we offer the user a way to use zulu times?  

    function formatDate(dateStr) {
      // Show local date/time
      return dateStr.toLocaleString();
    }

    function openHtmlInNewTab(htmlContent) {
      // Create a new Blob with the HTML content
      const blob = new Blob([htmlContent], { type: 'text/html' });

      // Create a URL for the Blob
      const url = URL.createObjectURL(blob);

      // Open a new tab and navigate to the Blob URL
      const newTab = window.open(url, '_blank');

      if (!newTab) {
          alert('Pop-up blocked! Please allow pop-ups for this website.');
      } else {
          // Optionally, revoke the URL once it's loaded to free resources
          newTab.onload = () => URL.revokeObjectURL(url);
      }
  }

  function showError(message) {
    const progressArea = document.getElementById('progress-area');
    const progressMessage = document.getElementById('progress-message');
    progressArea.classList.add('error');
    progressMessage.textContent = message;
    throw new Error(message); // This will terminate execution
  }

  </script>
</body>
</html>

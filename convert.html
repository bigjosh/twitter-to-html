<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Twitter Export to Static HTML</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem auto;
      max-width: 640px;
      text-align: center;
    }
    .container {
      border: 1px solid #ccc;
      padding: 1rem;
      background: #f9f9f9;
      border-radius: 8px;
    }
    h1 {
      margin-bottom: 1rem;
    }
    #file-input {
      margin-bottom: 1rem;
    }
    .textarea-container {
      margin-top: 1rem;
    }
    textarea {
      width: 100%;
      height: 300px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Twitter Export to Static HTML</h1>
    <p>Select your <code>tweets.js</code> (or <code>.json</code>) file to generate a static HTML archive.</p>
    <input type="file" id="file-input" accept=".js,.json" />

    <div class="textarea-container">
      <p><strong>Generated HTML Output:</strong></p>
      <textarea id="output-textarea" placeholder="Your static HTML will appear here..." readonly></textarea>
    </div>
  </div>

  <script>
    document.getElementById("file-input").addEventListener("change", async function() {
      const file = this.files[0];
      if (!file) return;

      try {
        // Read the file as text
        const fileContent = await file.text();

        // Attempt to remove any `window.YTD... = ` prefix if present, leaving valid JSON
        const cleanedContent = removePrefix(fileContent);

        // Parse JSON
        const tweetsArray = JSON.parse(cleanedContent);

        // Generate the static HTML
        const staticHTML = generateStaticHTML(tweetsArray);

        // Display it in the textarea
        document.getElementById("output-textarea").value = staticHTML;
      } catch (err) {
        alert("Error: " + err.message);
        console.error(err);
      }
    });

    /**
     * Removes `window.YTD.tweets.part0 = ` or similar prefix, if present, returning raw JSON text.
     */
    function removePrefix(content) {
      // Common patterns to remove:
      // e.g. window.YTD.tweets.part0 = [...];
      // You can adapt the regex for other variations
      return content
        .replace(/^window\.YTD\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\s*=\s*/, "") // remove prefix
        .replace(/;\s*$/, ""); // remove trailing semicolon if any
    }

    /**
     * Escapes HTML special characters in a string
     */
    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    /**
     * Generates a complete static HTML document from an array of tweet objects.
     * This HTML contains no JavaScript and references images in the `tweets_media` folder.
     */
    function generateStaticHTML(tweets) {
      // First pass: Build a map of tweet IDs to tweets and find root tweets
      const tweetMap = new Map();
      const rootTweets = new Set();
      
      for (const item of tweets) {
        const t = item.tweet || {};
        if (t.id_str) {
          tweetMap.set(t.id_str, t);
          
          // If this tweet is not a reply or is a reply to a tweet we don't have,
          // consider it a root tweet
          if (!t.in_reply_to_status_id_str || !tweetMap.has(t.in_reply_to_status_id_str)) {
            rootTweets.add(t.id_str);
          } else {
            // If this is a reply to a tweet we have, remove the replied-to tweet
            // from root tweets as it's part of a thread
            rootTweets.delete(t.in_reply_to_status_id_str);
          }
        }
      }

      // Helper function to render a single tweet
      function renderTweet(t, isThread = false) {
        const createdAt = formatDate(t.created_at);
        const textDecoded = decodeHtmlEntities(t.full_text || "(No text)");
        const textEscaped = escapeHtml(textDecoded);
        const tweetId = t.id_str;
        const tweetUrl = `https://x.com/i/web/status/${tweetId}`;

        // Check if this is a reply tweet
        let replyHtml = '';
        if (t.in_reply_to_status_id_str && t.in_reply_to_screen_name) {
          // Only show reply info if it's not part of a thread we're displaying
          if (!tweetMap.has(t.in_reply_to_status_id_str)) {
            const replyUrl = `https://x.com/${escapeHtml(t.in_reply_to_screen_name)}/status/${t.in_reply_to_status_id_str}`;
            replyHtml = `
    <div class="tweet-reply-info">
      In reply to <a href="${escapeHtml(replyUrl)}" target="_blank" rel="noopener noreferrer">@${escapeHtml(t.in_reply_to_screen_name)}</a>
    </div>`;
          }
        }

        // Build the media HTML, if any
        const mediaHtml = getMediaHtml(t);

        const threadClass = isThread ? ' thread-tweet' : '';
        return `
  <div class="tweet-container${threadClass}">${replyHtml}
    <div class="tweet-time">${escapeHtml(createdAt)}</div>
    <div class="tweet-text">${textEscaped}</div>
    <div class="tweet-media">${mediaHtml}</div>
    <div class="tweet-link">
      <a href="${escapeHtml(tweetUrl)}" target="_blank" rel="noopener noreferrer">View on X.com</a>
    </div>
  </div>`;
      }

      // Helper function to render a tweet and all its replies that we have
      function renderTweetThread(tweetId) {
        const thread = [];
        let currentTweetId = tweetId;
        
        // First, go up the reply chain to find the start of the thread
        while (currentTweetId) {
          const tweet = tweetMap.get(currentTweetId);
          if (!tweet) break;
          
          thread.unshift(tweet); // Add to start of array
          currentTweetId = tweet.in_reply_to_status_id_str;
          if (!tweetMap.has(currentTweetId)) break;
        }
        
        // Render the thread
        return thread.map((t, index) => renderTweet(t, index < thread.length - 1)).join('\n');
      }

      let html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>My Exported Tweets</title>
  <style>
    body {
      margin: 2rem auto;
      max-width: 600px;
      font-family: sans-serif;
      line-height: 1.4;
      background: #f9f9f9;
    }
    .tweet-container {
      background: #fff;
      margin-bottom: 1rem;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    .tweet-container.thread-tweet {
      margin-bottom: 2px;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }
    .tweet-container.thread-tweet + .tweet-container {
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      margin-top: -1px;
    }
    .tweet-reply-info {
      font-size: 0.85rem;
      color: #555;
      margin-bottom: 0.5rem;
    }
    .tweet-reply-info a {
      color: #1da1f2;
      text-decoration: none;
    }
    .tweet-time {
      color: #555;
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
    }
    .tweet-text {
      margin-bottom: 0.5rem;
      white-space: pre-wrap;
    }
    .tweet-media img {
      max-width: 100%;
      display: block;
      margin: 0.5rem 0;
    }
    .tweet-link a {
      font-size: 0.85rem;
      color: #1da1f2;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <h1>My Exported Tweets</h1>
`;

      // Second pass: Render tweets in order, handling threads
      for (const rootTweetId of rootTweets) {
        html += renderTweetThread(rootTweetId);
      }

      html += `
</body>
</html>
`;
      return html;
    }

    /**
     * Decodes common HTML entities (e.g. &amp;, &gt;, &lt;, etc.) so that
     * Twitter-escaped text will be rendered properly.
     */
    function decodeHtmlEntities(str) {
      const textarea = document.createElement("textarea");
      textarea.innerHTML = str;
      return textarea.value;
    }

    /**
     * Attempts to get media from `extended_entities.media` or `entities.media`.
     * Returns HTML <img> tags referencing `tweets_media/<filename>`.
     */
    function getMediaHtml(tweet) {
      let media = [];
      // Check extended_entities first
      if (tweet.extended_entities && tweet.extended_entities.media) {
        media = tweet.extended_entities.media;
      }
      // Then fall back to entities.media
      else if (tweet.entities && tweet.entities.media) {
        media = tweet.entities.media;
      }

      if (!Array.isArray(media) || media.length === 0) {
        return "";
      }

      let mediaHtml = "";
      media.forEach(m => {
        if (!m.media_url) return;
        const filename = m.media_url.split("/").pop(); // naive approach to get the file name
        // For images only; adjust logic if you have videos/GIFs
        mediaHtml += `<img src="tweets_media/${filename}" alt="Tweet media" />`;
      });
      return mediaHtml;
    }

    /**
     * Utility: formats the date string from Twitter's "created_at" field.
     */
    function formatDate(dateStr) {
      const d = new Date(dateStr);
      if (isNaN(d)) {
        // fallback if invalid
        return dateStr || "(Unknown date)";
      }
      // Show local date/time
      return d.toLocaleString();
    }
  </script>
</body>
</html>

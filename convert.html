<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Twitter Export to Static HTML</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem auto;
      max-width: 640px;
      text-align: center;
    }
    .container {
      border: 1px solid #ccc;
      padding: 1rem;
      background: #f9f9f9;
      border-radius: 8px;
    }
    h1 {
      margin-bottom: 1rem;
    }
    #file-input {
      margin-bottom: 1rem;
    }
    .textarea-container {
      margin-top: 1rem;
    }
    textarea {
      width: 100%;
      height: 300px;
    }
    .note-tweet-section {
      margin: 1rem 0;
    }
    #note-tweet-input {
      margin: 1rem 0;
      padding: 1rem;
      background: #f0f0f0;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Twitter Export to Static HTML</h1>
    <p>Select your <code>tweets.js</code> file and optionally your <code>note-tweets.js</code> file. If you don't include the note-tweets file, any tweets longer than the Twitter max limit will be truncated in the output, but there will be a link to view the full tweet on twitter.com.</p>
    <input type="file" id="file-input" accept=".js,.json" multiple />

    <div class="textarea-container">
      <p><strong>Generated HTML Output:</strong></p>
      <textarea id="output-textarea" placeholder="Your static HTML will appear here..." readonly></textarea>
    </div>
  </div>

  <script>
    // Global variable to store note tweets
    let noteTweets = null;

    document.getElementById("file-input").addEventListener("change", async function() {
      const files = Array.from(this.files);
      if (files.length === 0) return;

      try {
        // Find the tweets.js file (required)
        const tweetsFile = files.find(f => 
          f.name.toLowerCase().includes('tweets.js') && 
          !f.name.toLowerCase().includes('note-tweets')
        );
        if (!tweetsFile) {
          throw new Error("Please select your tweets.js file");
        }

        // Look for note-tweets.js (optional)
        const noteTweetsFile = files.find(f => 
          f.name.toLowerCase().includes('note-tweets')
        );
        
        // Load note tweets if available
        if (noteTweetsFile) {
          const noteContent = await noteTweetsFile.text();
          const cleanedNoteContent = removePrefix(noteContent);
          try {
            noteTweets = JSON.parse(cleanedNoteContent);
            console.log('Loaded note tweets:', noteTweets.length);
          } catch (e) {
            console.error('Error parsing note tweets:', e);
            noteTweets = null;
          }
        } else {
          noteTweets = null;
        }

        // Load main tweets
        const tweetsContent = await tweetsFile.text();
        const cleanedContent = removePrefix(tweetsContent);
        const tweetsArray = JSON.parse(cleanedContent);

        // Generate the static HTML
        const staticHTML = generateStaticHTML(tweetsArray);

        // Display it in the textarea
        document.getElementById("output-textarea").value = staticHTML;
      } catch (err) {
        alert("Error: " + err.message);
        console.error(err);
      }
    });

    /**
     * Removes `window.YTD... = ` or similar prefix, if present, returning raw JSON text.
     */
    function removePrefix(content) {
      // Common patterns to remove:
      // e.g. window.YTD.tweets.part0 = [...];
      // You can adapt the regex for other variations
      return content
        .replace(/^window\.YTD\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\s*=\s*/, "") // remove prefix
        .replace(/;\s*$/, ""); // remove trailing semicolon if any
    }

    /**
     * Escapes HTML special characters in a string
     */
    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    /**
     * Generates a complete static HTML document from an array of tweet objects.
     * This HTML contains no JavaScript and references images in the `tweets_media` folder.
     */
    function generateStaticHTML(tweets) {
      // First pass: Build a map of tweet IDs to tweets and find root tweets
      const tweetMap = new Map();
      const rootTweets = new Set();
      
      for (const item of tweets) {
        const t = item.tweet || {};
        if (t.id_str) {
          tweetMap.set(t.id_str, t);
          
          // If this tweet is not a reply or is a reply to a tweet we don't have,
          // consider it a root tweet
          if (!t.in_reply_to_status_id_str || !tweetMap.has(t.in_reply_to_status_id_str)) {
            rootTweets.add(t.id_str);
          } else {
            // If this is a reply to a tweet we have, remove the replied-to tweet
            // from root tweets as it's part of a thread
            rootTweets.delete(t.in_reply_to_status_id_str);
          }
        }
      }

      // Keep track of the last sequence of tweets rendered
      let lastSequence = [];

      // Helper function to render a single tweet
      function renderTweet(t, isThread = false) {
        // Mark this tweet as rendered
        const createdAt = formatDate(t.created_at);
        let textDecoded = decodeHtmlEntities(getFullTweetText(t));

        // Get media URLs to remove from text
        const mediaUrls = new Set();
        if (t.entities && Array.isArray(t.entities.media)) {
          t.entities.media.forEach(m => {
            if (m.url) {
              mediaUrls.add(m.url);
            }
          });
        }
        if (t.extended_entities && Array.isArray(t.extended_entities.media)) {
          t.extended_entities.media.forEach(m => {
            if (m.url) {
              mediaUrls.add(m.url);
            }
          });
        }

        // Remove media URLs from text
        mediaUrls.forEach(url => {
          textDecoded = textDecoded.replace(url, '');
        });

        // Trim any extra whitespace that might be left after removing URLs
        textDecoded = textDecoded.trim();
        
        const textEscaped = escapeHtml(textDecoded);
        const tweetId = t.id_str;
        const tweetUrl = `https://x.com/i/web/status/${tweetId}`;

        // Check if this is a reply tweet
        let replyHtml = '';
        if (t.in_reply_to_status_id_str && t.in_reply_to_screen_name) {
          // Only show reply info if it's not part of a thread we're displaying
          if (!tweetMap.has(t.in_reply_to_status_id_str)) {
            const replyUrl = `https://x.com/${escapeHtml(t.in_reply_to_screen_name)}/status/${t.in_reply_to_status_id_str}`;
            replyHtml = `
    <div class="tweet-reply-info">
      In reply to <a href="${escapeHtml(replyUrl)}" target="_blank" rel="noopener noreferrer">@${escapeHtml(t.in_reply_to_screen_name)}</a>
    </div>`;
          }
        }

        // Build the media HTML, if any
        const mediaHtml = getMediaHtml(t);

        const threadClass = isThread ? ' thread-tweet' : '';
        return `
  <div class="tweet-container${threadClass}">${replyHtml}
    <div class="tweet-time">${escapeHtml(createdAt)}</div>
    <div class="tweet-text">${textEscaped}</div>
    <div class="tweet-media">${mediaHtml}</div>
    <div class="tweet-link">
      <a href="${escapeHtml(tweetUrl)}" target="_blank" rel="noopener noreferrer">View on X.com</a>
    </div>
  </div>`;
      }

      // Helper function to render a tweet and all its replies that we have
      function renderTweetThread(tweetId) {
        const thread = [];
        let currentTweetId = tweetId;
        
        // First, go up the reply chain to find the start of the thread
        while (currentTweetId) {
          const tweet = tweetMap.get(currentTweetId);
          if (!tweet) break;
          thread.unshift(tweet); // Add to start of array
          currentTweetId = tweet.in_reply_to_status_id_str;
          if (!tweetMap.has(currentTweetId)) break;
        }

        // Compare with last sequence and remove any duplicates from the start
        let startIndex = 0;
        if (lastSequence.length > 0) {
          // Find how many tweets from the start match the last sequence
          while (startIndex < thread.length && 
                 startIndex < lastSequence.length && 
                 thread[startIndex].id_str === lastSequence[startIndex].id_str) {
            startIndex++;
          }
        }

        // If all tweets were duplicates, return empty string
        if (startIndex === thread.length) {
          return '';
        }

        // Update the last sequence to this thread
        lastSequence = thread;
        
        // Render only the non-duplicate tweets
        return thread.slice(startIndex)
                    .map((t, index, arr) => renderTweet(t, index < arr.length - 1))
                    .join('\n');
      }

      let html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>My Exported Tweets</title>
  <style>
    body {
      margin: 2rem auto;
      max-width: 600px;
      font-family: sans-serif;
      line-height: 1.4;
      background: #f9f9f9;
    }
    .tweet-container {
      background: #fff;
      margin-bottom: 1rem;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    .tweet-container.thread-tweet {
      margin-bottom: 2px;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }
    .tweet-container.thread-tweet + .tweet-container {
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      margin-top: -1px;
    }
    .tweet-media-grid {
      display: grid;
      grid-gap: 2px;
      margin: 0.5rem 0;
      border-radius: 8px;
      overflow: hidden;
    }
    .tweet-media-grid.grid-2 {
      grid-template-columns: repeat(2, 1fr);
    }
    .tweet-media-grid.grid-3 {
      grid-template-columns: repeat(2, 1fr);
    }
    .tweet-media-grid.grid-3 .media-item:first-child {
      grid-column: span 2;
    }
    .tweet-media-grid.grid-4 {
      grid-template-columns: repeat(2, 1fr);
    }
    .media-item {
      position: relative;
      overflow: hidden;
    }
    .media-item a {
      display: block;
      width: 100%;
      height: 100%;
    }
    .media-item a:hover {
      opacity: 0.9;
    }
    .media-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .tweet-reply-info {
      font-size: 0.85rem;
      color: #555;
      margin-bottom: 0.5rem;
    }
    .tweet-reply-info a {
      color: #1da1f2;
      text-decoration: none;
    }
    .tweet-time {
      color: #555;
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
    }
    .tweet-text {
      margin-bottom: 0.5rem;
      white-space: pre-wrap;
    }
    .tweet-link a {
      font-size: 0.85rem;
      color: #1da1f2;
      text-decoration: none;
    }
    .truncated-note {
      font-size: 0.9em;
      color: #536471;
    }
    .truncated-note a {
      color: #1da1f2;
      text-decoration: none;
    }
    .truncated-note a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>My Exported Tweets</h1>
`;

      // Second pass: Render tweets in order, handling threads
      for (const rootTweetId of rootTweets) {
        const threadHtml = renderTweetThread(rootTweetId);
        if (threadHtml) {
          html += threadHtml;
        } else {
          // If no tweets were rendered, clear the last sequence
          // This ensures tweets will be repeated if they're not directly consecutive
          lastSequence = [];
        }
      }

      html += `
</body>
</html>
`;
      return html;
    }

    /**
     * Decodes common HTML entities (e.g. &amp;, &gt;, &lt;, etc.) so that
     * Twitter-escaped text will be rendered properly.
     */
    function decodeHtmlEntities(str) {
      const textarea = document.createElement("textarea");
      textarea.innerHTML = str;
      return textarea.value;
    }

    /**
     * Attempts to get media from `extended_entities.media` or `entities.media`.
     * Returns HTML <img> tags referencing `tweets_media/<filename>`.
     */
    function getMediaHtml(tweet) {
      let media = [];
      
      // Check extended_entities first as it contains the full media info
      if (tweet.extended_entities && Array.isArray(tweet.extended_entities.media)) {
        media = tweet.extended_entities.media;
      }
      // Fall back to entities.media if no extended_entities
      else if (tweet.entities && Array.isArray(tweet.entities.media)) {
        media = tweet.entities.media;
      }

      if (media.length === 0) {
        return "";
      }

      let mediaHtml = '<div class="tweet-media-grid">\n';
      
      // Add a CSS class based on number of media items
      const gridClass = media.length > 1 ? ` grid-${Math.min(media.length, 4)}` : '';
      mediaHtml = `<div class="tweet-media-grid${gridClass}">\n`;

      media.forEach(m => {
        if (!m.media_url_https && !m.media_url) return;
        
        // Prefer HTTPS URL if available
        const mediaUrl = m.media_url_https || m.media_url;
        const filename = mediaUrl.split("/").pop();
        
        // Get the type of media and original dimensions
        const mediaType = m.type || 'photo';
        const width = m.sizes?.large?.w || m.sizes?.medium?.w || 600;
        const height = m.sizes?.large?.h || m.sizes?.medium?.h || 400;
        
        if (mediaType === 'photo') {
          // Construct the correct path: tweets_media/tweet_id-filename
          const mediaPath = `data/tweets_media/${tweet.id_str}-${filename}`;
          
          mediaHtml += `  <div class="media-item">
    <a href="${mediaPath}" target="_blank" rel="noopener noreferrer">
      <img src="${mediaPath}" 
           alt="Tweet media" 
           width="${width}" 
           height="${height}"
           loading="lazy" />
    </a>
  </div>\n`;
        }
        // Add support for other media types here if needed
      });
      
      mediaHtml += '</div>';
      return mediaHtml;
    }

    /**
     * Get the full tweet text, checking note-tweets.js if available
     */
    function getFullTweetText(tweet) {
      // First check if this is a note tweet
      if (noteTweets && tweet.id_str) {
        // Find matching note tweet
        const noteTweet = noteTweets.find(nt => 
          nt && nt.tweet && nt.tweet.id === tweet.id_str
        );
        if (noteTweet && noteTweet.tweet && noteTweet.tweet.note_tweet) {
          return noteTweet.tweet.note_tweet.text || tweet.full_text;
        }
      }
      
      // If not a note tweet or note tweets not loaded, return original text
      const text = tweet.full_text || "(No text)";
      if (text.endsWith('…') && !noteTweets) {
        const tweetUrl = `https://twitter.com/i/web/status/${tweet.id_str}`;
        return `${text} <span class="truncated-note">(<a href="${tweetUrl}" target="_blank" rel="noopener noreferrer">read full tweet on twitter.com</a>)</span>`;
      }
      return text;
    }

    /**
     * Utility: formats the date string from Twitter's "created_at" field.
     */
    function formatDate(dateStr) {
      const d = new Date(dateStr);
      if (isNaN(d)) {
        // fallback if invalid
        return dateStr || "(Unknown date)";
      }
      // Show local date/time
      return d.toLocaleString();
    }
  </script>
</body>
</html>

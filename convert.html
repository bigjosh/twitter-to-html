<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Twitter Export to Static HTML</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem auto;
      max-width: 640px;
      text-align: center;
    }
    .container {
      border: 1px solid #ccc;
      padding: 1rem;
      background: #f9f9f9;
      border-radius: 8px;
    }
    h1 {
      margin-bottom: 1rem;
    }
    #file-input {
      margin-bottom: 1rem;
    }
    .textarea-container {
      margin-top: 1rem;
    }
    textarea {
      width: 100%;
      height: 300px;
    }
    .note-tweet-section {
      margin: 1rem 0;
    }
    #note-tweet-input {
      margin: 1rem 0;
      padding: 1rem;
      background: #f0f0f0;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Twitter Export to Static HTML</h1>
    <p>Select your <code>tweets.js</code> file and optionally your <code>note-tweets.js</code> file. If you don't include the note-tweets file, any tweets longer than the Twitter max limit will be truncated in the output, but there will be a link to view the full tweet on twitter.com.</p>
    <input type="file" id="file-input" accept=".js,.json" multiple />

    <div class="textarea-container">
      <p><strong>Generated HTML Output:</strong></p>
      <textarea id="output-textarea" placeholder="Your static HTML will appear here..." readonly></textarea>
    </div>
  </div>

  <script>

    /**
     * Removes `window.YTD... = ` or similar prefix, if present, returning raw JSON text.
     */
    function removeJavaScriptPrefix(content) {
      // Common patterns to remove:
      // e.g. window.YTD.tweets.part0 = [...];
      // You can adapt the regex for other variations
      return content
        .replace(/^window\.YTD\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\s*=\s*/, "") // remove prefix
        .replace(/;\s*$/, ""); // remove trailing semicolon if any
    }

    // Global variable to store note tweets in a map where the key is the cleaned noteTweet text
    // Defaults to null becuase it is optional for the user to pass a notes-tweets.js file
    let notesArray = null;

    document.getElementById("file-input").addEventListener("change", async function() {
      const files = Array.from(this.files);
      if (files.length === 0) return;

      try {
        // Find the tweets.js file (required)
        const tweetsFile = files.find(f => f.name.toLowerCase() === 'tweets.js');
        if (!tweetsFile) {
          throw new Error("Please select your tweets.js file");
        }

        // Load main tweets into tweetsArray
        tweetsContent = await tweetsFile.text();
        tweetsContentCleaned = removeJavaScriptPrefix(tweetsContent);
        tweetsContent = null;   // Free up memory
        const tweetsArray = JSON.parse(tweetsContentCleaned).map( o=> o.tweet );    // Every tweet is in an object called `tweet`, so flatten that out for simplicity
        tweetsContentCleaned = null;  // Free up memory

        // Look for note-tweets.js (optional)
        const noteTweetsFile = files.find(f => f.name.toLowerCase() === 'note-tweets.js');
        
        // Load note tweets if available
        if (noteTweetsFile) {
          const noteContent = await noteTweetsFile.text();
          const noteCleanContent = removeJavaScriptPrefix(noteContent);   // Remove the varabile name at the top of the file so just pure JSON
          notesArray = JSON.parse( noteContent).map( o=> o.noteTweet );    // Every noteTweet is in an object called `noteTweet`, so flatten that out for simplicity            
        }


        // Generate the static HTML
        const staticHTML = generateStaticHTML(tweetsArray,notesArray);

        // Display it in the textarea
        document.getElementById("output-textarea").value = staticHTML;

        // Create an "Open in New Tab" button if it doesn't exist
        let openButton = document.getElementById("open-tab-button");
        if (!openButton) {
          openButton = document.createElement("button");
          openButton.id = "open-tab-button";
          openButton.textContent = "Open in New Tab";
          openButton.onclick = () => openHtmlInNewTab(staticHTML);
          document.getElementById("output-textarea").insertAdjacentElement('afterend', openButton);
        }

      } catch (err) {
        alert("Error: " + err.message);
        console.error(err);
      }
    });


    /**
     * Escapes HTML special characters in a string
     * The tweets.js already has some chars escaped like ampersand and gt and lt
     * but it does not escape carridge return or quotes.
     * TODO: Are there others?  
     */
    function escapeSpecialCharsToHtml(str) {
      return str.replace("\n", "<br>").replace("\"", "&quot;");
    }

    /**
     * Generates a complete static HTML document from an array of tweet objects.
     * This HTML contains no JavaScript and references images in the `tweets_media` folder.
     * notes will be null if no notes-tweets.js file was included
     */
    function generateStaticHTML(tweets,notes) {

      count = 0;

      // First lets get the date into a normalized format for all the tweets
      // We also need to add a sequence number so we can keep tweet strorms in thier orginal ordering (they have idential timestamps and the ID numbers are not monotonically increasing)
      tweets.forEach (tweet => {
        tweet.timestamp = new Date(tweet.created_at);        
        tweet.sequence = count;
        count = count + 1;
      });

      // Now we can sort the tweets by date, oldest first.
      // This makes displaying tweetstorms more natural, and also maybe better for SEO?
      // TODO: Should we also delete the `created_at` property as we go to save space?

      // It seems that tweetstorms all get the same timestamp, so we add `id_str` to break ties 
      // Assumes that tweet IDs are assigned monotonically. IS that true?

      // Highest time number is 2^32 = 10 digits
      // Assume no one has more than 10 million tweets

      tweets = tweets.sort((a, b) =>  {

        // If two tweets have the same timestamp, the one that came earlier in the tweet.js file should come first
        if (a.timestamp.getTime() === b.timestamp.getTime()) {
          return b.sequence - a.sequence;  // Highest sequnce first since threaded tweets come in inverse order int tweets.js
        }

        // Sort by timestamp, oldest first
        return a.timestamp.getTime() - b.timestamp.getTime();     

      });
    

      // If we were passed notes, then build a map of the text part so we can later look to find a matching tweet

      // We need a map becuase the long note might have URLs in it and if those URLs are past the end of the shortened
      // tweet then we need to get them from `ulrs` in the noteTweet
          
      let notesMap = null;        // Will be null if no notes-tweets.js file was included
      if (notes) {
        notesArray = notes;
        notesMap = new Map();
        notesArray.forEach(note => {
            notesMap.set( note.noteTweet.core.text , note);   // Store the original long text as key and a ref to the full note as element
        });
      }


      // Build a map of tweet IDs to tweets so we can later find replies
      const tweetMap = new Map();

      // TODO: do we need this?
      tweets.forEach(tweet => {
        tweetMap.set(tweet.id_str, tweet);
      });
      
      
/*

      for (const item of tweets) {
        const t = item.tweet || {};

        if (t.id_str) {
          tweetMap.set(t.id_str, t);
          
          // If this tweet is not a reply or is a reply to a tweet we don't have,
          // consider it a root tweet
          if (!t.in_reply_to_status_id_str || !tweetMap.has(t.in_reply_to_status_id_str)) {
            rootTweets.add(t.id_str);
          } else {
            // If this is a reply to a tweet we have, remove the replied-to tweet
            // from root tweets as it's part of a thread
            rootTweets.delete(t.in_reply_to_status_id_str);
          }
        } else {
          console.log(`Error: Tweet ID not found in tweet object: ${JSON.stringify(item)}`);
        }
      }
*/

      // Helper function to render a single tweet
      function renderTweet(t, isThread = false) {

        const createdAt = formatDate(t.timestamp);

        // Get the media URLs for this tweet
        // Seams like entities and extended_entities are rendundant? We use a set so it doesn't matter. 
        const mediaUrls = new Set();
        if (t.entities && Array.isArray(t.entities.media)) {
          t.entities.media.forEach(m => {
            if (m.url) {
              mediaUrls.add(m.url);
            }
          });
        }
        if (t.extended_entities && Array.isArray(t.extended_entities.media)) {
          t.extended_entities.media.forEach(m => {
            if (m.url) {
              mediaUrls.add(m.url);
            }
          });
        }

        // Remove media URLs from text
        // We only need to do this in the short tweet since it seems media is not included in the long note tweet
        let text = t.full_text;

        mediaUrls.forEach(url => {
          text = text.replace(url, '');
        });

        // Trim any extra whitespace that might be left after removing URLs
        text = text.trim();

        // Text is now the short tweet with media URLs removed
        
        // Next remove any leading mentions. We will add them as a different element from the usermentions array in entities. 
        // Not only do they look ugly at the begining there, they will also break our ability to find this tweet in notetweets

        while (text.startsWith('@')) {
          // Find the end of the username (space or end of string)
          let spaceIndex = text.indexOf(' ');
          if (spaceIndex === -1) {
              text = '';  // If no space found, the entire text is a mention
              break;
          }
          // Skip the mention and the following space
          text = text.slice(spaceIndex + 1).trimStart();          
        }

        console.log( "t:" + JSON.stringify(t, null, 4) );
        console.log( "entities:" + JSON.stringify(t.entities, null, 4) );
        if (t.entities && t.entities.user_mentions) console.log( "entities+mentions:" + JSON.stringify(t.entities.user_mentions, null, 4) );

        // now create the html for the mentions section
        let mentionsHtml = '';
        if (t.entities && t.entities.user_mentions && t.entities.user_mentions.length > 0) {
          console.log("making table");  
          mentionsHtml += `<table>\r`;              
          t.entities.user_mentions.forEach(m => {
            mentionsHtml += ` <tr><td><a href="https://x.com/${m.screen_name}" target="_blank" rel="noopener noreferrer">@${m.screen_name}</a></td><td>${m.name}</td></tr>\r`;              
          });
          mentionsHtml += `</table>\r`;              
        }
              
        // text now has external embeded URLs expaned and media URLs removed and any trailing spaces removed.
        // This should be 


        // TODO: Check if this is a note tweet and if so replace the text

        // TODO: After we check if it is a note, then exapnd any embeded URLs

        // It seams that media is only included in the short version of the tweet and not the long note version
        
        const tweetId = t.id_str;
        const tweetUrl = `https://x.com/i/web/status/${tweetId}`;

        // Check if this is a reply tweet
        let replyHtml = '';

        // Suppress the reply to line if this is in a thread (so it is obviously a reply to the tweet above it)
        if (t.in_reply_to_status_id_str && !isThread) {  
          const replyUrl = `https://x.com/${t.in_reply_to_screen_name}/status/${t.in_reply_to_status_id_str}`;
          replyHtml = `In reply to <a href="${replyUrl}" target="_blank" rel="noopener noreferrer">@${t.in_reply_to_screen_name}/${t.in_reply_to_status_id_str}</a>`;
        }

        // Build the media HTML, if any
        const mediaHtml = getMediaHtml(t);

        // Note that below we do not use a div for the mentions table since it is usually not present so no need to waste that space unless needed

        const threadClass = isThread ? ' thread-tweet' : '';

        // Finally we will build up the final html for the tweet so we can return it. 

        let tweetHTML = "";

        tweetHTML += `<div class="tweet-container${threadClass}" id="tweet-${tweetId}">\r`;
        tweetHTML += `  <div class="tweet-time"> <a href="${tweetUrl}" target="_blank" rel="noopener noreferrer">${createdAt}</a> </div>\r`;  

        if (replyHtml) {
          tweetHTML += `  <div class="tweet-reply-info">${replyHtml}</div>\r`;  
        }

        if (mentionsHtml) {  
          tweetHTML += `   <div class="tweet-mentions">${mentionsHtml}</div>\r`;  
        }

        tweetHTML += `   <div class="tweet-text">${escapeSpecialCharsToHtml(text)}</div>\r`;

        if (mediaHtml) {
          tweetHTML += `   <div class="tweet-media">${mediaHtml}</div>\r`;
        }
        tweetHTML += `</div>\r`;

        return tweetHTML;
      }

      // Helper function to render a tweet and all its replies that we have
      function renderTweetThread(tweetId) {
        const thread = [];
        let currentTweetId = tweetId;
        
        // First, go up the reply chain to find the start of the thread
        while (currentTweetId) {
          const tweet = tweetMap.get(currentTweetId);
          if (!tweet) break;
          thread.unshift(tweet); // Add to start of array
          currentTweetId = tweet.in_reply_to_status_id_str;
          if (!tweetMap.has(currentTweetId)) break;
        }

        // Compare with last sequence and remove any duplicates from the start
        let startIndex = 0;
        if (lastSequence.length > 0) {
          // Find how many tweets from the start match the last sequence
          while (startIndex < thread.length && 
                 startIndex < lastSequence.length && 
                 thread[startIndex].id_str === lastSequence[startIndex].id_str) {
            startIndex++;
          }
        }

        // If all tweets were duplicates, return empty string
        if (startIndex === thread.length) {
          return '';
        }

        // Update the last sequence to this thread
        lastSequence = thread;
        
        // Render only the non-duplicate tweets
        return thread.slice(startIndex)
                    .map((t, index, arr) => renderTweet(t, index < arr.length - 1))
                    .join('\n');
      }

      let html = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8" />
          <title>My Exported ${tweets.length} Tweets</title>
          <style>
            body {
              margin: 2rem auto;
              max-width: 600px;
              font-family: sans-serif;
              line-height: 1.4;
              background: #f9f9f9;
            }
            .tweet-container {
              background: #fff;
              margin-top: 1rem;
              margin-bottom: 1px;
              padding: 1rem;
              border: 1px solid #ddd;
              border-radius: 8px;
            }
            .tweet-container.thread-tweet {                   /* Visually make thread connect to the tweet above them */
              margin-top: 1px;
              border-top: none;         
              border-top-left-radius: 0;
              border-top-right-radius: 0;
            }
            .tweet-media-grid {
              display: grid;
              grid-gap: 2px;
              margin: 0.5rem 0;
              border-radius: 8px;
              overflow: hidden;
            }
            .tweet-media-grid.grid-2 {
              grid-template-columns: repeat(2, 1fr);
            }
            .tweet-media-grid.grid-3 {
              grid-template-columns: repeat(2, 1fr);
            }
            .tweet-media-grid.grid-3 .media-item:first-child {
              grid-column: span 2;
            }
            .tweet-media-grid.grid-4 {
              grid-template-columns: repeat(2, 1fr);
            }
            .media-item {
              position: relative;
              overflow: hidden;
            }
            .media-item a {
              display: block;
              width: 100%;
              height: 100%;
            }
            .media-item a:hover {
              opacity: 0.9;
            }
            .media-item img {
              width: 100%;
              height: 100%;
              object-fit: cover;
              display: block;
            }
            .tweet-reply-info {
              font-size: 0.85rem;
              color: #555;
              margin-bottom: 0.5rem;
            }
            .tweet-reply-info a {
              color: #1da1f2;
              text-decoration: none;
            }
            .tweet-time {
              color: #555;
              font-size: 0.85rem;
              margin-bottom: 0.5rem;
            }
            .tweet-text {
              margin-bottom: 0.5rem;
              white-space: pre-wrap;
            }
            .tweet-link a {
              font-size: 0.85rem;
              color: #1da1f2;
              text-decoration: none;
            }
            .tweet-mentions {
              margin-top: -0.5rem;
              margin-bottom: 1rem;
              font-size: 0.9rem;
              color: #536471;
            }
            .tweet-mentions table {
              border-collapse: collapse;
            }
            .tweet-mentions td {
              padding: 0.2rem 1rem 0.2rem 0;
            }
            .tweet-mentions a {
              text-decoration: none;
              color: #1DA1F2;
            }
            .tweet-mentions a:hover {
              text-decoration: underline;
            }
          </style>
        </head>
        <body>
          <h1>My Exported Tweets</h1>
      `;

      html +=`Total tweets: ${tweets.length}<br>`;

      previousTweetId = null;

      tweets.forEach(tweet => {

        // TODO: Progess report

        if (tweet.in_reply_to_status_id_str && tweet.in_reply_to_status_id_str === previousTweetId) {
            // This is a reply to own own tweet that immedeately preceeded this one, 
            // so show as a thread. This visually connects the tweets and also suppresses the "in reply to" line
            isThread = true;
        } else {
          isThread=false;        
        }

        // TODO: Get rid of tweetmap we don't need it anymore

        html += renderTweet(tweet,isThread);   
        
        // Remeber this tweet so we can check if the next one is a reply to it
        previousTweetId = tweet.id_str;

      });
  
      html += `
        </body>
        </html>
      `;
      return html;
    }

    /**
     * Attempts to get media from `extended_entities.media` or `entities.media`.
     * Returns HTML <img> tags referencing `tweets_media/<filename>`.
     */
    function getMediaHtml(tweet) {
      let media = [];
      
      // Check extended_entities first as it contains the full media info
      if (tweet.extended_entities && Array.isArray(tweet.extended_entities.media)) {
        media = tweet.extended_entities.media;
      }
      // Fall back to entities.media if no extended_entities
      else if (tweet.entities && Array.isArray(tweet.entities.media)) {
        media = tweet.entities.media;
      }

      if (media.length === 0) {
        return "";
      }

      let mediaHtml = '<div class="tweet-media-grid">\n';
      
      // Add a CSS class based on number of media items
      const gridClass = media.length > 1 ? ` grid-${Math.min(media.length, 4)}` : '';
      mediaHtml = `<div class="tweet-media-grid${gridClass}">\n`;

      media.forEach(m => {
        if (!m.media_url_https && !m.media_url) return;
        
        // Prefer HTTPS URL if available
        const mediaUrl = m.media_url_https || m.media_url;
        const filename = mediaUrl.split("/").pop();
        
        // Get the type of media and original dimensions
        const mediaType = m.type || 'photo';
        const width = m.sizes?.large?.w || m.sizes?.medium?.w || 600;
        const height = m.sizes?.large?.h || m.sizes?.medium?.h || 400;
        
        if (mediaType === 'photo') {
          // Construct the correct path: tweets_media/tweet_id-filename
          const mediaPath = `data/tweets_media/${tweet.id_str}-${filename}`;
          
          mediaHtml += `
            <div class="media-item">
            <a href="${mediaPath}" target="_blank" rel="noopener noreferrer">
              <img src="${mediaPath}" 
                  alt="Tweet media" 
                  width="${width}" 
                  height="${height}"
                  loading="lazy" />
            </a>
          </div>\n`;
        }
        // Add support for other media types here if needed
      });
      
      mediaHtml += '</div>';
      return mediaHtml;
    }

/*

    // Iterate through tweets and print the appropriate text
    tweets.forEach(tweet => {
        const tweetText = cleanText(tweet.tweet.full_text); // Clean tweet text
        let foundMatch = false;

        for (const [key, value] of noteTweetMap) {
            if (tweetText.startsWith(key)) { // Check if cleaned tweet text matches the beginning of a noteTweet
                console.log(`Long form: ${value}`);
                foundMatch = true;
                break;
            }
        }

        if (!foundMatch) {
            console.log(`Original text: ${tweet.tweet.full_text.trim()}`);
        }
    });

*/
    /**
     * Get the full tweet text, checking note-tweets.js if available
     */
    function getFullTweetText(tweet) {
      // First check if this is a note tweet
      if (notesArray && tweet.id_str) {
        const noteTweet = notesArray.find(nt => 
          nt.tweet && nt.tweet.id_str === tweet.id_str
        );
        if (noteTweet && noteTweet.tweet.note_tweet) {
          return noteTweet.tweet.note_tweet.text;
        }
      }
      
      // If not a note tweet or note tweets not loaded, return original text
      // and add a visual indicator if the tweet appears to be truncated
      const text = tweet.full_text || "(No text)";
      if (text.endsWith('…') && !notesArray) {
        return text + ' <a href="https://x.com/i/web/status/' + tweet.id_str + 
               '" target="_blank" rel="noopener noreferrer">(click to read full tweet)</a>';
      }
      return text;
    }

    /**
     * Utility: formats the date string into a tweet friendly format
     */

    // TODO: Should we offer the user a way to use zulu times?  

    function formatDate(dateStr) {
      // Show local date/time
      return dateStr.toLocaleString();
    }

    function openHtmlInNewTab(htmlContent) {
      // Create a new Blob with the HTML content
      const blob = new Blob([htmlContent], { type: 'text/html' });

      // Create a URL for the Blob
      const url = URL.createObjectURL(blob);

      // Open a new tab and navigate to the Blob URL
      const newTab = window.open(url, '_blank');

      if (!newTab) {
          alert('Pop-up blocked! Please allow pop-ups for this website.');
      } else {
          // Optionally, revoke the URL once it's loaded to free resources
          newTab.onload = () => URL.revokeObjectURL(url);
      }
  }

  </script>
</body>
</html>
